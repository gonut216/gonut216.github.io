<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="golang,golang source,network,">










<meta name="description" content="操作系统上的 I/O 是用户空间和内核空间的数据交互，通常包含以下两个步骤：   等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&amp;gt; 读取/写入到内核缓冲区 从内核缓冲区复制数据 –&amp;gt; 用户空间(读)/从用户空间复制数据 -&amp;gt; 内核缓冲区(写)   而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是">
<meta name="keywords" content="golang,golang source,network">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解Golang网络轮询器NetPoller">
<meta property="og:url" content="http://yoursite.com/2021/08/24/IOMultiplexing/index.html">
<meta property="og:site_name" content="Wxning">
<meta property="og:description" content="操作系统上的 I/O 是用户空间和内核空间的数据交互，通常包含以下两个步骤：   等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&amp;gt; 读取/写入到内核缓冲区 从内核缓冲区复制数据 –&amp;gt; 用户空间(读)/从用户空间复制数据 -&amp;gt; 内核缓冲区(写)   而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/io-1.png">
<meta property="og:image" content="http://yoursite.com/images/io-2.png">
<meta property="og:image" content="http://yoursite.com/images/io-3.png">
<meta property="og:updated_time" content="2021-08-30T09:30:18.173Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解Golang网络轮询器NetPoller">
<meta name="twitter:description" content="操作系统上的 I/O 是用户空间和内核空间的数据交互，通常包含以下两个步骤：   等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&amp;gt; 读取/写入到内核缓冲区 从内核缓冲区复制数据 –&amp;gt; 用户空间(读)/从用户空间复制数据 -&amp;gt; 内核缓冲区(写)   而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是">
<meta name="twitter:image" content="http://yoursite.com/images/io-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/24/IOMultiplexing/">





  <title>深入理解Golang网络轮询器NetPoller | Wxning</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/wxning1107" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wxning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-个人简历">
          <a href="/个人简历/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            个人简历
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/24/IOMultiplexing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wxning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解Golang网络轮询器NetPoller</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-24T17:10:59+08:00">
                2021-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang-计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">golang - 计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>操作系统上的 I/O 是用户空间和内核空间的数据交互，通常包含以下两个步骤：</p>
<blockquote>
<ol>
<li>等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&gt; 读取/写入到内核缓冲区</li>
<li>从内核缓冲区复制数据 –&gt; 用户空间(读)/从用户空间复制数据 -&gt; 内核缓冲区(写)</li>
</ol>
</blockquote>
<p>而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是同步 I/O，否则，就是异步 I/O。</p>
<h2 id="阻塞I-O与非阻塞I-O"><a href="#阻塞I-O与非阻塞I-O" class="headerlink" title="阻塞I/O与非阻塞I/O"></a>阻塞I/O与非阻塞I/O</h2><p>当我们通过 <code>read</code> 或者 <code>write</code> 等系统调用读写文件或者网络时，应用程序会被阻塞，当我们执行 <code>read</code> 系统调用时，应用程序会从用户态陷入内核态，内核会检查文件描述符是否可读，当文件描述符中存在数据时，操作系统内核会将准备好的数据拷贝给应用程序并交回控制权。</p>
<p>非阻塞I/O就是所有 I/O 操作都是立刻返回而不会阻塞当前用户进程，当进程把一个文件描述符设置成非阻塞时，执行 <code>read</code> 和 <code>write</code> 等 I/O 操作会立刻返回，下面是C语言代码，<a href="https://github.com/torvalds/linux/blob/f757165705e92db62f85a1ad287e9251d1f2cd82/fs/fcntl.c#L448" target="_blank" rel="noopener"><code>fcntl</code></a> 为我们提供了操作文件描述符的能力，我们可以通过它修改文件描述符的特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">fcntl(fd, F_SETFL, flags | O_NONBLOCK);</span><br></pre></td></tr></table></figure>

<p>当我们将文件描述符修改成非阻塞后，读写文件会经历以下流程：</p>
<p><img src="/images/io-1.png" alt="io"></p>
<p>如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 <code>EAGAIN</code> error，<code>EAGAIN</code> 意味着该文件描述符还在等待缓冲区中的数据，随后，应用程序会不断轮询调用 <code>read</code> 直到它的返回值大于 0，这时应用程序就可以对读取操作系统缓冲区中的数据并进行操作。从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。进程使用非阻塞的 I/O 操作时，可以在等待过程中执行其他任务，提高 CPU 的利用率。</p>
<h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p><strong>所谓 I/O 多路复用指的就是 select/poll/epoll 这一系列的多路选择器：支持单一线程同时监听多个文件描述符（I/O 事件），阻塞等待，并在其中某个文件描述符可读写时收到通知。 I/O 复用其实复用的不是 I/O 连接，而是复用线程，让一个 thread of control 能够处理多个连接（I/O 事件）。</strong></p>
<h2 id="select-amp-poll"><a href="#select-amp-poll" class="headerlink" title="select &amp; poll"></a>select &amp; poll</h2><p>select 是 epoll 之前 Linux 使用的 I/O 事件驱动技术。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* According to earlier standards */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// nfds是监听的文件描述符的集合中的最大文件描述符加1。readset是读事件集合，writeset是写事件集合，exceptset是异常事件集合，若如果对某一个集合不感兴趣，就可以把它设为NULL</span></span><br><span class="line"> <span class="comment">// 返回值：若有就绪描述符返回其数目，若超时则为0，若出错则为-1</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 和 select 紧密结合的四个宏：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 在文件描述符集合中删除一个文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">//指定的文件描述符是否在该集合中，如fd在文件描述符集中，返回非0值，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 在文件描述符集合中增加一个新的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>; <span class="comment">// 清空文件描述符集</span></span><br></pre></td></tr></table></figure>

<p>下面是一个<code>select</code>例子，创建 5 个子进程，每个进程连接到服务器并向服务器发送消息，服务器进程使用 accept 为每个客户端创建不同的文件描述符，<code>select</code> 中的第一个参数应该是三个集合中任何一个中编号最大的文件描述符加上 1。创建一组所有文件描述符，调用 <code>select</code> 并在返回时检查哪个文件描述符已准备好读取。<code>select</code> 返回时， 将集合更改为仅包含准备好的文件描述符，因此我们需要在每次迭代时再次构建该集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXBUF 256</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_process</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  sleep(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">char</span> msg[MAXBUF];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> n, sockfd,num=<span class="number">1</span>;</span><br><span class="line">  srandom(getpid());</span><br><span class="line">  <span class="comment">/* Create socket and connect to server */</span></span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = inet_addr(<span class="string">"127.0.0.1"</span>);</span><br><span class="line"></span><br><span class="line">  connect(sockfd, (struct sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child &#123;%d&#125; connected \n"</span>, getpid());</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> sl = (random() % <span class="number">10</span> ) +  <span class="number">1</span>;</span><br><span class="line">        num++;</span><br><span class="line">     	sleep(sl);</span><br><span class="line">  	<span class="built_in">sprintf</span> (msg, <span class="string">"Test message %d from client %d"</span>, num, getpid());</span><br><span class="line">  	n = write(sockfd, msg, <span class="built_in">strlen</span>(msg));	<span class="comment">/* Send message */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[MAXBUF];</span><br><span class="line">  <span class="keyword">int</span> fds[<span class="number">5</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">  <span class="comment">// 用于记录最大的fd位置</span></span><br><span class="line">  <span class="keyword">int</span> addrlen, n,i,max=<span class="number">0</span>;;</span><br><span class="line">  <span class="keyword">int</span> sockfd, commfd;</span><br><span class="line">  fd_set rset;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="keyword">if</span>(fork() == <span class="number">0</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">  		child_process();</span><br><span class="line">  		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span> (addr));</span><br><span class="line">  addr.sin_family = AF_INET;</span><br><span class="line">  addr.sin_port = htons(<span class="number">2000</span>);</span><br><span class="line">  addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">  bind(sockfd,(struct sockaddr*)&amp;addr ,<span class="keyword">sizeof</span>(addr));</span><br><span class="line">  listen (sockfd, <span class="number">5</span>); </span><br><span class="line">	<span class="comment">// 创建5个文件描述符</span></span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    <span class="comment">// 声明文件描述符</span></span><br><span class="line">    fds[i] = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    <span class="keyword">if</span>(fds[i] &gt; max)</span><br><span class="line">    	max = fds[i];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="comment">// 由于select后的rset会被置位，所有每次循环需要对rset置空，然后再将fds赋给rset</span></span><br><span class="line">	FD_ZERO(&amp;rset);</span><br><span class="line">  	<span class="keyword">for</span> (i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  		FD_SET(fds[i],&amp;rset);</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line">  <span class="comment">// rset是一个bitmap  </span></span><br><span class="line">  <span class="comment">// 阻塞，每次需要把fd从用户态拷贝到内核态 </span></span><br><span class="line">  <span class="comment">// 当有I/O数据时，select返回，并且将rset置位，没数据的位会被清空  </span></span><br><span class="line">	select(max+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 遍历，判断哪个fd被置位</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(fds[i], &amp;rset))&#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">      <span class="comment">// 读数据</span></span><br><span class="line">			read(fds[i], buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解 select 的关键在于理解 <code>fd_set</code>，为说明方便，取 <code>fd_set</code> 长度为 1 字节，fd_set 中的每一 bit 可以对应一个文件描述符 <code>fd</code>，则 1 字节长的 <code>fd_set</code> 最大可以对应 8 个 fd。select 的调用过程如下：</p>
<blockquote>
<ol>
<li>执行 FD_ZERO(&amp;set), 则 set 用位表示是 <code>0000,0000</code></li>
<li>若 fd＝5, 执行 FD_SET(fd, &amp;set); 后 set 变为 0001,0000(第 5 位置为 1)</li>
<li>再加入 fd＝2, fd=1，则 set 变为 <code>0001,0011</code></li>
<li>执行 select(6, &amp;set, 0, 0, 0) 阻塞等待（这里max是5+1，这是因为set最大只能是5，内核没必要把所有set位都取出来，只需要最大到6的位置）</li>
<li>若 fd=1, fd=2 上都发生可读事件，则 select 返回，此时 set 变为 <code>0000,0011</code> (注意：没有事件发生的 fd=5 被清空)</li>
</ol>
</blockquote>
<p><strong>根据上面例子我们可以得出<code>select</code>的特点：</strong></p>
<hr>
<blockquote>
<ul>
<li>可监控的文件描述符个数取决于 sizeof(fd_set) 的值。假设服务器上 sizeof(fd_set)＝512，每 bit 表示一个文件描述符，则服务器上支持的最大文件描述符是 512*8=4096。</li>
<li>将 fd 加入 select 监控集的同时，还要再使用一个数据结构 array 保存放到 select 监控集中的 fd，一是用于在 select 返回后，array 作为源数据和 fd_set 进行 FD_ISSET 判断。二是 select 返回后会把以前加入的但并无事件发生的 fd 清空，则每次开始 select 前都要重新从 array 取得 fd 逐一加入（FD_ZERO 最先），扫描 array 的同时取得 fd 最大值 maxfd，用于 select 的第一个参数，可见 select 模型必须在 select 前循环 array（加 fd，取 maxfd），select 返回后循环 array（FD_ISSET 判断是否有事件发生）</li>
<li>select会将rset全量拷贝到内核态，由内核态判读rset是否有数据，这是因为如果由用户态判断，也是交给内核态真正执行，每一个位的判断都需要用户态和内核态的切换，所以select直接将rset拷贝到内核态</li>
</ul>
</blockquote>
<hr>
<p><strong>所以，select 有如下的缺点：</strong></p>
<hr>
<blockquote>
<ul>
<li>监听能力有限：使用 32 个整数的 32 位，即 32*32=1024 来标识 fd，最多只能监听 1024 个文件描述符（可调整）</li>
<li>内存拷贝开销大：每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li>
<li>时间复杂度 𝑂(𝑛)：每次 kernel 都需要线性扫描整个 fd_set，所以随着监控的描述符 fd 数量增长，其 I/O 性能会线性下降，而且，rset不可重用，每次循环都要对rset置空再赋值，性能有损耗</li>
</ul>
</blockquote>
<hr>
<p>对比<code>select</code>，poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而不是 select 的 fd_set 结构， <code>poll</code> 函数使用链表存储文件描述符，摆脱了 1024 的数量上限。但是同样需要从用户态拷贝所有的 fd 到内核态，也需要线性遍历所有的 fd 集合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fds是一个poll函数监听的结构列表，nfds表示fds数组的长度</span></span><br><span class="line"><span class="comment">// 返回值：小于0，表示出错，等于0，表示poll函数等待超时，大于0，表示struct pollfd结构体数组中有多少个非0的revents，也就是这一次调用poll产生事件的描述符的数量。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>与<code>select</code>不同，poll传入的是pollfd结构体数组，所以没有1024个描述符的限制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> fd; <span class="comment">// 文件描述符</span></span><br><span class="line">      <span class="keyword">short</span> events; <span class="comment">// 关心的事件类型</span></span><br><span class="line">      <span class="keyword">short</span> revents; <span class="comment">// 实际发生了的事件类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事件类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLIN         0x001        <span class="comment">// 有数据可读</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLPRI        0x002        <span class="comment">// 有紧迫数据可读</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLOUT        0x004        <span class="comment">// 现在写数据不会导致阻塞</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> POLLRDNORM    0x040        <span class="comment">// 有普通数据可读</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> POLLRDBAND    0x080        <span class="comment">// 有优先数据可读</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> POLLWRNORM    0x100        <span class="comment">// 写普通数据不会导致阻塞</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> POLLWRBAND    0x200        <span class="comment">// 写优先数据不会导致阻塞</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLERR        0x008        <span class="comment">// 发生错误</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLHUP        0x010        <span class="comment">// 挂起</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POLLNVAL       0x020        <span class="comment">// 无效文件描述符</span></span></span><br></pre></td></tr></table></figure>

<p>当一个文件描述符要同时监听读写事件时，可以写成 events = POLLIN | POLLOUT</p>
<p>下面是<code>poll</code>的例子，与<code>select</code>用法相似，仍然需要从用户态拷贝所有的 <code>fd</code> 到内核态，也需要线性遍历所有的 <code>fd</code> 集合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 5个文件描述符</span></span><br><span class="line"> <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">   addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">   <span class="comment">// 声明文件描述符</span></span><br><span class="line">   pollfds[i].fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">   <span class="comment">// events是读事件</span></span><br><span class="line">   pollfds[i].events = POLLIN;</span><br><span class="line"> &#125;</span><br><span class="line"> sleep(<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line"> <span class="comment">// 传入pollfd数组，并且数组中有5个元素，50000是超时</span></span><br><span class="line">poll(pollfds, <span class="number">5</span>, <span class="number">50000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">   <span class="comment">// 判断revents是否被置位为POLLIN</span></span><br><span class="line">	<span class="keyword">if</span> (pollfds[i].revents &amp; POLLIN)&#123;</span><br><span class="line">     <span class="comment">// 恢复为0</span></span><br><span class="line">		pollfds[i].revents = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">		read(pollfds[i].fd, buffer, MAXBUF);</span><br><span class="line">		<span class="built_in">puts</span>(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>与<code>select</code>不同的是，<code>poll</code>不是对bitmap置位，而且改变<code>revents</code>字段（<code>select</code>对bitmap置位导致rset不可重用），这里会对<code>revents</code>字段赋值为<code>POLLIN</code>，即读事件，<code>poll</code>返回后需要对<code>revents</code>字段恢复为0。<code>poll</code>解决了<code>select</code>监听能力受限的问题，也解决了bitmap重用的问题，但是仍然需要内存拷贝以及时间复杂度𝑂(𝑛)的问题。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>I/O 多路复用的核心设计是 1 个线程处理所有连接的 <code>等待消息准备好</code> I/O 事件，这一点上 <code>epoll</code> 和 <code>select</code>&amp;<code>poll</code> 是大同小异的。但 <code>select</code>&amp;<code>poll</code>在十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。<code>select&amp;</code>&amp;<code>poll</code> 的使用方法是这样的： <code>返回的活跃连接 == select(全部待监控的连接)</code> 。什么时候会调用 <code>select</code>&amp;<code>poll</code> 呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，<code>select</code>&amp;<code>poll</code> 在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被 <code>高频</code> 二字所放大。它有效率损失吗？显而易见，全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。被放大后就会发现，处理并发上万个连接时，<code>select</code>&amp;<code>poll</code> 就完全力不从心了。这个时候就该 <code>epoll</code> 上场了，<code>epoll</code> 通过一些新的设计和优化，基本上解决了 <code>select</code>&amp;<code>poll</code> 的问题。</p>
<p>epoll 的 API 非常简洁，涉及到的只有 3 个系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;  </span></span></span><br><span class="line"><span class="comment">// size表明内核要监听的描述符数量</span></span><br><span class="line"><span class="comment">// 返回一个epoll句柄描述符，失败时返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>; <span class="comment">// int epoll_create1(int flags);</span></span><br><span class="line"><span class="comment">// epfd 表示epoll句柄</span></span><br><span class="line"><span class="comment">// op 表示fd操作类型，有如下3种：</span></span><br><span class="line"><span class="comment">// 1.EPOLL_CTL_ADD 注册新的fd到epfd中</span></span><br><span class="line"><span class="comment">// 2.EPOLL_CTL_MOD 修改已注册的fd的监听事件</span></span><br><span class="line"><span class="comment">// 3.EPOLL_CTL_DEL 从epfd中删除一个fd</span></span><br><span class="line"><span class="comment">// fd 是要监听的描述符</span></span><br><span class="line"><span class="comment">// event 表示要监听的事件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="comment">// epfd 是epoll句柄</span></span><br><span class="line"><span class="comment">// events 表示从内核得到的就绪事件集合</span></span><br><span class="line"><span class="comment">// maxevents 告诉内核events的大小</span></span><br><span class="line"><span class="comment">// timeout 表示等待的超时事件</span></span><br><span class="line"><span class="comment">// 返回值：返回就绪的事件数目，调用失败时返回 -1，等待超时返回 0。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>epoll_create</code> 创建一个 <code>epoll</code> 实例并返回 <code>epollfd</code>，<code>epoll_ctl</code> 注册 file descriptor 等待的 I/O 事件(比如 EPOLLIN、EPOLLOUT 等) 到 <code>epoll</code> 实例上，<code>epoll_wait</code> 则是阻塞监听 <code>epoll</code> 实例上所有的 file descriptor 的 I/O 事件，它接收一个用户空间上的一块内存地址 (events 数组)，kernel 会在有 I/O 事件发生的时候把文件描述符列表复制到这块内存地址上，然后 <code>epoll_wait</code> 解除阻塞并返回，最后用户空间上的程序就可以对相应的 <code>fd</code> 进行读写了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>

<p><code>epoll</code>能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。原因就是获取事件的时候，它<code>无须遍历整个被侦听的描述符集</code>，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[5];</span></span><br><span class="line">  <span class="keyword">int</span> epfd = epoll_create(<span class="number">10</span>);</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;client, <span class="number">0</span>, <span class="keyword">sizeof</span> (client));</span><br><span class="line">    addrlen = <span class="keyword">sizeof</span>(client);</span><br><span class="line">    ev.data.fd = accept(sockfd,(struct sockaddr*)&amp;client, &amp;addrlen);</span><br><span class="line">    ev.events = EPOLLIN;</span><br><span class="line">    epoll_ctl(epfd, EPOLL_CTL_ADD, ev.data.fd, &amp;ev); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="built_in">puts</span>(<span class="string">"round again"</span>);</span><br><span class="line">  	nfds = epoll_wait(epfd, events, <span class="number">5</span>, <span class="number">10000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;i++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="number">0</span>,MAXBUF);</span><br><span class="line">      <span class="comment">// 从events数组中获取对应fd即可，无需遍历所有描述符集</span></span><br><span class="line">			read(events[i].data.fd, buffer, MAXBUF);</span><br><span class="line">			<span class="built_in">puts</span>(buffer);</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>epoll</code> 的工作原理如下：</p>
<p><img src="/images/io-2.png" alt="io"></p>
<p>与 <code>select</code>&amp;<code>poll</code> 相比，<code>epoll</code> 分清了高频调用和低频调用。例如，<code>epoll_ctl</code> 相对来说就是非频繁调用的，而 <code>epoll_wait</code> 则是会被高频调用的。所以 <code>epoll</code> 利用 <code>epoll_ctl</code> 来插入或者删除一个 fd，实现用户态到内核态的数据拷贝，这确保了每一个 fd 在其生命周期只需要被拷贝一次，而不是每次调用 <code>epoll_wait</code> 的时候都拷贝一次。 <code>epoll_wait</code> 则被设计成几乎没有入参的调用，相比  <code>select</code>&amp;<code>poll</code>需要把全部监听的 fd 集合从用户态拷贝至内核态的做法，<code>epoll</code> 的效率就高出了一大截。</p>
<p>在实现上 <code>epoll</code> 采用<code>红黑树</code>来存储所有监听的 fd，<strong>而红黑树本身插入和删除性能比较稳定，时间复杂度 O(logN)</strong>。通过 <code>epoll_ctl</code> 函数添加进来的 fd 都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把 fd 添加进来的时候时候会完成关键的一步：该 fd 会与相应的设备（网卡）驱动程序建立回调关系，也就是在内核中断处理程序为它注册一个回调函数，在 fd 相应的事件触发（中断）之后（设备就绪了），内核就会调用这个回调函数，该回调函数在内核中被称为： <code>ep_poll_callback</code> ，<strong>这个回调函数其实就是把这个 fd 添加到 rdllist 这个双向链表（就绪链表）中</strong>。<code>epoll_wait</code> 实际上就是去检查 rdllist 双向链表中是否有就绪的 fd，当 rdllist 为空（无就绪 fd）时挂起当前进程，直到 rdllist 非空时进程才被唤醒并返回。</p>
<p>相比于  <code>select</code>&amp;<code>poll</code> 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态，<code>epoll_wait</code> 则是直接返回已就绪 fd，因此 <code>epoll</code> 的 I/O 性能不会像  <code>select</code>&amp;<code>poll</code> 那样随着监听的 fd 数量增加而出现线性衰减，是一个非常高效的 I/O 事件驱动技术。</p>
<p><strong>由于使用 <code>epoll</code> 的 I/O 多路复用需要用户进程自己负责 I/O 读写，从用户进程的角度看，读写过程是阻塞的，所以 <code>select</code>&amp;<code>poll</code>&amp;<code>epoll</code> 本质上都是同步 I/O 模型，而像 Windows 的 IOCP 这一类的异步 I/O，只需要在调用 WSARecv 或 WSASend 方法读写数据的时候把用户空间的内存 buffer 提交给 kernel，kernel 负责数据在用户空间和内核空间拷贝，完成之后就会通知用户进程，整个过程不需要用户进程参与，所以是真正的异步 I/O。</strong></p>
<p><code>epoll</code> 的工作模式:</p>
<p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）</strong>和<strong>ET（edge trigger）</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：<br>　　<strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序可以不立即处理该事件</code>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。<br>　　<strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<code>应用程序必须立即处理该事件</code>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p>
<h2 id="go-netPoller"><a href="#go-netPoller" class="headerlink" title="go netPoller"></a>go netPoller</h2><p><strong>Go netpoller 基本原理</strong></p>
<blockquote>
<p>Go netpoller 通过在底层对 epoll/kqueue/iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 <code>netFD</code> 为中心实现。netFD 与底层 <code>PollDesc</code> 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时，就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 <code>gopark</code> 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll/kqueue/iocp 等事件驱动机制。</p>
</blockquote>
<p>为了提高 I/O 多路复用的性能，不同的操作系统也都实现了自己的 I/O 多路复用函数，例如：<code>epoll</code>、<code>kqueue</code> 和 <code>evport</code> 等。Go 语言为了提高在不同操作系统上的 I/O 操作性能，使用平台特定的函数实现了多个版本的网络轮询模块：</p>
<blockquote>
<ul>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_epoll.go" target="_blank" rel="noopener"><code>src/runtime/netpoll_epoll.go</code></a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_kqueue.go" target="_blank" rel="noopener"><code>src/runtime/netpoll_kqueue.go</code></a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_solaris.go" target="_blank" rel="noopener"><code>src/runtime/netpoll_solaris.go</code></a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_windows.go" target="_blank" rel="noopener"><code>src/runtime/netpoll_windows.go</code></a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_aix.go" target="_blank" rel="noopener"><code>src/runtime/netpoll_aix.go</code></a></li>
<li><a href="https://github.com/golang/go/blob/master/src/runtime/netpoll_fake.go" target="_blank" rel="noopener"><code>src/runtime/netpoll_fake.go</code></a></li>
</ul>
</blockquote>
<p>我们只针对<code>epoll</code>版本</p>
<h2 id="网络轮询器接口"><a href="#网络轮询器接口" class="headerlink" title="网络轮询器接口"></a>网络轮询器接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpoll</span><span class="params">(delta <span class="keyword">int64</span>)</span> <span class="title">gList</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollBreak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollIsPollDescriptor</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<p>上述函数在网络轮询器中分别扮演了不同的作用：</p>
<ul>
<li><code>runtime.netpollinit</code> — 初始化网络轮询器，通过 <code>sync.Once</code> 和 <code>netpollInited</code> 变量保证函数只会调用一次</li>
<li><code>runtime.netpollopen</code> — 监听文件描述符上的边缘触发事件，创建事件并加入监听</li>
<li><code>runtime.netpoll</code>— 轮询网络并返回一组已经准备就绪的 Goroutine，传入的参数会决定它的行为：<ul>
<li>如果参数小于 0，无限期等待文件描述符就绪；</li>
<li>如果参数等于 0，非阻塞地轮询网络；</li>
<li>如果参数大于 0，阻塞特定时间轮询网络；</li>
</ul>
</li>
<li><code>runtime.netpollBreak</code> — 唤醒网络轮询器，例如：计时器向前修改时间时会通过该函数中断网络轮询器</li>
<li><code>runtime.netpollIsPollDescriptor</code> — 判断文件描述符是否被轮询器使用</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><strong>netFD</strong></p>
<p><code>net.Listen(&quot;tcp&quot;, &quot;:8888&quot;)</code> 方法返回了一个 *TCPListener，它是一个实现了 <code>net.Listener</code> 接口的 struct，而通过 <code>listener.Accept()</code> 接收的新连接 *TCPConn 则是一个实现了 <code>net.Conn</code> 接口的 struct，它内嵌了 <code>net.conn</code> struct。不管是 Listener 的 Accept 还是 Conn 的 Read/Write 方法，都是基于一个 <code>netFD</code> 的数据结构的操作， <code>netFD</code> 是一个网络描述符，类似于 Linux 的文件描述符的概念，netFD 中包含一个 poll.FD 数据结构，而 poll.FD 中包含两个重要的数据结构 <code>Sysfd</code> 和 <code>pollDesc</code>， <code>Sysfd</code> 是真正的系统文件描述符，<code>pollDesc</code>对是底层事件驱动的封装，所有的读写超时等操作都是通过调用<code>pollDesc</code>的对应方法实现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络描述符</span></span><br><span class="line"><span class="keyword">type</span> netFD <span class="keyword">struct</span> &#123;</span><br><span class="line">	pfd poll.FD</span><br><span class="line"></span><br><span class="line">	<span class="comment">// immutable until Close</span></span><br><span class="line">	family      <span class="keyword">int</span></span><br><span class="line">	sotype      <span class="keyword">int</span></span><br><span class="line">	isConnected <span class="keyword">bool</span> <span class="comment">// handshake completed or use of association with peer</span></span><br><span class="line">	net         <span class="keyword">string</span></span><br><span class="line">	laddr       Addr</span><br><span class="line">	raddr       Addr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FD is a file descriptor. The net and os packages use this type as a</span></span><br><span class="line"><span class="comment">// field of a larger type representing a network connection or OS file.</span></span><br><span class="line"><span class="keyword">type</span> FD <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Lock sysfd and serialize access to Read and Write methods.</span></span><br><span class="line">	fdmu fdMutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// System file descriptor. Immutable until Close.</span></span><br><span class="line">	<span class="comment">// 真正的系统文件描述符</span></span><br><span class="line">	Sysfd <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// I/O poller.</span></span><br><span class="line">	<span class="comment">// 对是底层事件驱动的封装，所有的读写超时等操作都是通过调用pollDesc的对应方法实现的。</span></span><br><span class="line">	pd pollDesc</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Writev cache.</span></span><br><span class="line">	iovecs *[]syscall.Iovec</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Semaphore signaled when file is closed.</span></span><br><span class="line">	csema <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Non-zero if this file has been set to blocking mode.</span></span><br><span class="line">	isBlocking <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether this is a streaming descriptor, as opposed to a</span></span><br><span class="line">	<span class="comment">// packet-based descriptor like a UDP socket. Immutable.</span></span><br><span class="line">	IsStream <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether a zero byte read indicates EOF. This is false for a</span></span><br><span class="line">	<span class="comment">// message based socket connection.</span></span><br><span class="line">	ZeroReadIsEOF <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Whether this is a file rather than a network socket.</span></span><br><span class="line">	isFile <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>pollDesc</strong></p>
<p>pollDesc 是底层事件驱动的封装，netFD 通过它来完成各种 I/O 相关的操作，它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 底层事件驱动的封装，netFD 通过它来完成各种 I/O 相关的操作</span><br><span class="line">type pollDesc struct &#123;</span><br><span class="line">	runtimeCtx uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 struct 只包含了一个指针，而通过 pollDesc 的 init 方法，我们可以找到它具体的定义是在 <code>runtime.pollDesc</code> 这里：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// netFD.init 会调用 poll.FD.Init 并最终调用到 pollDesc.init，</span></span><br><span class="line"><span class="comment">// 它会创建 epoll 实例并把 listener fd 加入监听队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">init</span><span class="params">(fd *FD)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// runtime_pollServerInit 通过 `go:linkname` 链接到具体的实现函数 poll_runtime_pollServerInit，</span></span><br><span class="line">	<span class="comment">// 接着再调用 netpollGenericInit，然后会根据不同的系统平台去调用特定的 netpollinit 来创建 epoll 实例</span></span><br><span class="line">	serverInit.Do(runtime_pollServerInit)</span><br><span class="line">	<span class="comment">// runtime_pollOpen 内部调用了 netpollopen 来将 listener fd 注册到 epoll 实例中，另外，它会初始化一个 pollDesc 并返回</span></span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="keyword">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ctx != <span class="number">0</span> &#123;</span><br><span class="line">			runtime_pollUnblock(ctx)</span><br><span class="line">			runtime_pollClose(ctx)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把真正初始化完成的 pollDesc 实例赋值给当前的 pollDesc 代表自身的指针，</span></span><br><span class="line">	<span class="comment">// 后续使用直接通过该指针操作</span></span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Network poller descriptor.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// No heap pointers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> pollDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">	link *pollDesc <span class="comment">// in pollcache, protected by pollcache.lock</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.</span></span><br><span class="line">	<span class="comment">// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.</span></span><br><span class="line">	<span class="comment">// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)</span></span><br><span class="line">	<span class="comment">// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated</span></span><br><span class="line">	<span class="comment">// in a lock-free way by all operations.</span></span><br><span class="line">	<span class="comment">// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),</span></span><br><span class="line">	<span class="comment">// that will blow up when GC starts moving objects.</span></span><br><span class="line">	lock    mutex <span class="comment">// protects the following fields</span></span><br><span class="line">	fd      <span class="keyword">uintptr</span></span><br><span class="line">	closing <span class="keyword">bool</span></span><br><span class="line">	everr   <span class="keyword">bool</span>    <span class="comment">// marks event scanning error happened</span></span><br><span class="line">	user    <span class="keyword">uint32</span>  <span class="comment">// user settable cookie</span></span><br><span class="line">	rseq    <span class="keyword">uintptr</span> <span class="comment">// protects from stale read timers</span></span><br><span class="line">	<span class="comment">// 取值分别可能是 pdReady、pdWait、等待 file descriptor 就绪的 goroutine 也就是 g 数据结构以及 nil，它们是实现唤醒 goroutine 的关键</span></span><br><span class="line">	rg   <span class="keyword">uintptr</span> <span class="comment">// pdReady, pdWait, G waiting for read or nil</span></span><br><span class="line">	rt   timer   <span class="comment">// read deadline timer (set if rt.f != nil)</span></span><br><span class="line">	rd   <span class="keyword">int64</span>   <span class="comment">// read deadline</span></span><br><span class="line">	wseq <span class="keyword">uintptr</span> <span class="comment">// protects from stale write timers</span></span><br><span class="line">	<span class="comment">// 取值分别可能是 pdReady、pdWait、等待 file descriptor 就绪的 goroutine 也就是 g 数据结构以及 nil，它们是实现唤醒 goroutine 的关键</span></span><br><span class="line">	wg   <span class="keyword">uintptr</span>   <span class="comment">// pdReady, pdWait, G waiting for write or nil</span></span><br><span class="line">	wt   timer     <span class="comment">// write deadline timer</span></span><br><span class="line">	wd   <span class="keyword">int64</span>     <span class="comment">// write deadline</span></span><br><span class="line">	self *pollDesc <span class="comment">// storage for indirect interface. See (*pollDesc).makeArg.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>rseq</code> 和 <code>wseq</code> 表示文件描述符被重用或者计时器被重置。</p>
<p><code>rd</code> 和 <code>wd</code>表示等待文件描述符可读或者可写的截止日期。</p>
<p><code>rt</code> 和 <code>wt</code>表示用于等待文件描述符的计时器。</p>
<p>操作系统中 I/O 多路复用函数会监控文件描述符的可读或者可写，而 Go 语言网络轮询器会监听 <code>runtime.pollDesc</code>结构体的状态，它会封装操作系统的文件描述符，这里重点关注里面的 <code>rg</code> 和 <code>wg</code>，这里两个 uintptr “万能指针”类型，取值分别可能是 <code>pdReady</code>、<code>pdWait</code>、等待文件描述符可读或可写的 Goroutine 也就是 <code>g</code> 数据结构以及 <code>nil</code>，它们是实现唤醒 goroutine 的关键。</p>
<p><code>runtime.pollDesc</code> 包含自身类型的一个指针，用来保存下一个 <code>runtime.pollDesc</code> 的地址，以此来实现链表，可以减少数据结构的大小，所有的 <code>runtime.pollDesc</code> 保存在 <code>runtime.pollCache</code> 结构中，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 runtime.pollCache 是一个在 runtime 包里的全局变量，因此需要用一个互斥锁来避免 data race 问题，从它的名字也能看出这是一个用于缓存的数据结构，也就是用来提高性能的</span></span><br><span class="line"><span class="keyword">type</span> pollCache <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock  mutex</span><br><span class="line">	first *pollDesc</span><br><span class="line">	<span class="comment">// PollDesc objects must be type-stable,</span></span><br><span class="line">	<span class="comment">// because we can get ready notification from epoll/kqueue</span></span><br><span class="line">	<span class="comment">// after the descriptor is closed/reused.</span></span><br><span class="line">	<span class="comment">// Stale notifications are detected using seq variable,</span></span><br><span class="line">	<span class="comment">// seq is incremented when deadlines are changed or descriptor is reused.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>runtime.pollCache</code> 是一个在 runtime 包里的全局变量，因此需要用一个互斥锁来避免 data race 问题，从它的名字也能看出这是一个用于缓存的数据结构，也就是用来提高性能的，具体如何实现呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化总大小约为 4KB 的 runtime.pollDesc 结构体的链表</span></span><br><span class="line"><span class="comment">// 每次调用该结构体都会返回链表头还没有被使用的 runtime.pollDesc，这种批量初始化的做法能够增加网络轮询器的吞吐量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">alloc</span><span class="params">()</span> *<span class="title">pollDesc</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="comment">// 判断链表头是否已经分配过值，若是，则直接返回表头这个 pollDesc，这种批量初始化数据进行缓存而后每次都直接从缓存取数据的方式是一种很常见的性能优化手段，在这里这种方式可以有效地提升 netpoller 的吞吐量</span></span><br><span class="line">	<span class="keyword">if</span> c.first == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">const</span> pdSize = unsafe.Sizeof(pollDesc&#123;&#125;)</span><br><span class="line">		n := pollBlockSize / pdSize</span><br><span class="line">		<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">			n = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Must be in non-GC memory because can be referenced</span></span><br><span class="line">		<span class="comment">// only from epoll/kqueue internals.</span></span><br><span class="line">		<span class="comment">// runtime.persistentalloc 会保证这些数据结构初始化在不会触发垃圾回收的内存中，让这些数据结构只能被内部的 epoll 和 kqueue 模块引用</span></span><br><span class="line">		mem := persistentalloc(n*pdSize, <span class="number">0</span>, &amp;memstats.other_sys)</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">uintptr</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">			pd := (*pollDesc)(add(mem, i*pdSize))</span><br><span class="line">			pd.link = c.first</span><br><span class="line">			c.first = pd</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	pd := c.first</span><br><span class="line">	c.first = pd.link</span><br><span class="line">	lockInit(&amp;pd.lock, lockRankPollDesc)</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">return</span> pd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go runtime 会在调用 <code>poll_runtime_pollOpen</code> 往 epoll 实例注册 fd 之时首次调用 <code>runtime.pollCache.alloc</code>方法时批量初始化大小 4KB 的 <code>runtime.pollDesc</code> 结构体的链表，初始化过程中会调用 <code>runtime.persistentalloc</code> 来为这些数据结构分配不会被 GC 回收的内存，确保这些数据结构只能被 <code>epoll</code>和<code>kqueue</code> 在内核空间去引用。</p>
<p>再往后每次调用这个方法则会先判断链表头是否已经分配过值了，若是，则直接返回表头这个 <code>pollDesc</code>，这种批量初始化数据进行缓存而后每次都直接从缓存取数据的方式是一种很常见的性能优化手段，在这里这种方式可以有效地提升 netpoller 的吞吐量。</p>
<p>Go runtime 运行时会调用 <code>runtime.pollCache.free</code>方法释放已经用完的 <code>runtime.pollDesc</code> 结构，它会直接将结构体插入链表的最前面：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go runtime 会在关闭 pollDesc 之时调用 runtime.pollCache.free 释放内存</span></span><br><span class="line"><span class="comment">// 释放已经用完的 runtime.pollDesc 结构，它会直接将结构体插入链表的最前面</span></span><br><span class="line"><span class="comment">// 没有重置 runtime.pollDesc 结构体中的字段，该结构体被重复利用时才会由 runtime.poll_runtime_pollOpen 函数重置。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *pollCache)</span> <span class="title">free</span><span class="params">(pd *pollDesc)</span></span> &#123;</span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	pd.link = c.first</span><br><span class="line">	c.first = pd</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法没有重置 <code>runtime.pollDesc</code>结构体中的字段，该结构体被重复利用时才会由 <code>runtime.poll_runtime_pollOpen</code>函数重置。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p> epoll 的三个基本调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;  </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Go 在源码里实现了对那三个调用的封装：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go 对上面三个调用的封装</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">netpoll</span><span class="params">(block <span class="keyword">bool</span>)</span> <span class="title">gList</span></span></span><br></pre></td></tr></table></figure>

<p>netFD 就是通过这三个封装来对 epoll 进行创建实例、注册 fd 和等待事件操作的。</p>
<p>使用 Go 编写一个典型的 TCP echo server:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	listen, _ := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8888"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, _ := listen.Accept()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// start a new goroutine to handle the new connection.</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> conn.Close()</span><br><span class="line">			packet := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// block here if socket is not available for reading data.</span></span><br><span class="line">				n, _ := conn.Read(packet)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// same as above, block here if socket is not available for writing.</span></span><br><span class="line">				_, _ = conn.Write(packet[:n])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个基于 Go 原生网络模型（基于 netpoller）编写的一个 TCP server，模式是 <code>goroutine-per-connection</code> ，在这种模式下，开发者使用的是同步的模式去编写异步的逻辑而且对于开发者来说 I/O 是否阻塞是无感知的，也就是说开发者无需考虑 goroutines 甚至更底层的线程、进程的调度和上下文切换。而 Go netpoller 最底层的事件驱动技术肯定是基于 epoll/kqueue/iocp 这一类的 I/O 事件驱动技术，只不过是把这些调度和上下文切换的工作转移到了 runtime 的 Go scheduler，让它来负责调度 goroutines，从而极大地降低了程序员的心智负担！</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>调用 <code>net.Listen</code> 之后，底层会通过 Linux 的系统调用 <code>socket</code> 方法创建一个 fd 分配给 listener，并用以来初始化 listener 的 <code>netFD</code> ，接着调用 netFD 的 <code>listenStream</code> 方法完成对 socket 的 bind&amp;listen 操作以及对 <code>netFD</code> 的初始化（主要是对 netFD 里的 pollDesc 的初始化）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr, ctrlFn <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>, syscall.RawConn)</span> <span class="title">error</span>) <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">	s, err := sysSocket(family, sotype, proto)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(s)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> sotype &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line">			<span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fd.Close()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line">			<span class="keyword">if</span> err := fd.listenDatagram(laddr, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				fd.Close()</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr, ctrlFn); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fd.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对 netFD 初始化，最后调用 <code>netpollinit</code> 方法，这就是上面提到的对 <code>epoll_create</code> 的封装。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">init</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fd.pfd.Init(fd.net, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Init</span><span class="params">(net <span class="keyword">string</span>, pollable <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> net == <span class="string">"file"</span> &#123;</span><br><span class="line">		fd.isFile = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !pollable &#123;</span><br><span class="line">		fd.isBlocking = <span class="number">1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	err := fd.pd.init(fd)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fd.isBlocking = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serverInit sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">init</span><span class="params">(fd *FD)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	serverInit.Do(runtime_pollServerInit)</span><br><span class="line">	ctx, errno := runtime_pollOpen(<span class="keyword">uintptr</span>(fd.Sysfd))</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> ctx != <span class="number">0</span> &#123;</span><br><span class="line">			runtime_pollUnblock(ctx)</span><br><span class="line">			runtime_pollClose(ctx)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> errnoErr(syscall.Errno(errno))</span><br><span class="line">	&#125;</span><br><span class="line">	pd.runtimeCtx = ctx</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollServerInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	netpollGenericInit()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollGenericInit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;netpollInited) == <span class="number">0</span> &#123;</span><br><span class="line">		lockInit(&amp;netpollInitLock, lockRankNetpollInit)</span><br><span class="line">		lock(&amp;netpollInitLock)</span><br><span class="line">		<span class="keyword">if</span> netpollInited == <span class="number">0</span> &#123;</span><br><span class="line">			netpollinit()</span><br><span class="line">			atomic.Store(&amp;netpollInited, <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;netpollInitLock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>netpollinit主要做：</p>
<blockquote>
<ol>
<li>调用 <code>epollcreate1</code> 创建一个 epoll 实例 <code>epfd</code>，作为整个 runtime 的唯一 event-loop 使用；</li>
<li>调用 <code>runtime.nonblockingPipe</code> 创建一个用于和 epoll 实例通信的管道，这里为什么不用更新且更轻量的 eventfd 呢？我个人猜测是为了兼容更多以及更老的系统版本；</li>
<li>将 <code>netpollBreakRd</code> 通知信号量封装成 <code>epollevent</code> 事件结构体注册进 epoll 实例。</li>
</ol>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化网络轮询器，通过 sync.Once 和 netpollInited 变量保证函数只会调用一次</span></span><br><span class="line"><span class="comment">// netpollinit 会创建一个 epoll 实例，然后把 epoll fd 赋值给 epfd，</span></span><br><span class="line"><span class="comment">// 后续 listener 以及它 accept 的所有 sockets 有关 epoll 的操作都是基于这个全局的 epfd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例，等于: int epoll_create(int size);</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 调用 epollcreate1 创建一个 epoll 实例 epfd，作为整个 runtime 的唯一 event-loop 使用</span></span><br><span class="line">	epfd = epollcreate1(_EPOLL_CLOEXEC)</span><br><span class="line">	<span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">		epfd = epollcreate(<span class="number">1024</span>)</span><br><span class="line">		<span class="keyword">if</span> epfd &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"runtime: epollcreate failed with"</span>, -epfd)</span><br><span class="line">			throw(<span class="string">"runtime: netpollinit failed"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		closeonexec(epfd)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调用 runtime.nonblockingPipe 创建一个用于和 epoll 实例通信的管道，这里为什么不用更新且更轻量的 eventfd 呢？我个人猜测是为了兼容更多以及更老的系统版本</span></span><br><span class="line">	r, w, errno := nonblockingPipe()</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"runtime: pipe failed with"</span>, -errno)</span><br><span class="line">		throw(<span class="string">"runtime: pipe failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将 netpollBreakRd 通知信号量封装成 epollevent 事件结构体注册进 epoll 实例</span></span><br><span class="line">	ev := epollevent&#123;</span><br><span class="line">		events: _EPOLLIN,</span><br><span class="line">	&#125;</span><br><span class="line">	*(**<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd</span><br><span class="line">	errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)</span><br><span class="line">	<span class="keyword">if</span> errno != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">"runtime: epollctl failed with"</span>, -errno)</span><br><span class="line">		throw(<span class="string">"runtime: epollctl failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	netpollBreakRd = <span class="keyword">uintptr</span>(r)</span><br><span class="line">	netpollBreakWr = <span class="keyword">uintptr</span>(w)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>init 中会调用 runtime_pollOpen 方法，<code>netpollopen</code> 会被 runtime_pollOpen 调用，用于注册 fd 到 epoll 实例。这里使用的是 epoll 的 ET 模式，同时会利用万能指针把 pollDesc 保存到 epollevent 的一个 8 位的字节数组 data 里。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollOpen</span><span class="params">(fd <span class="keyword">uintptr</span>)</span> <span class="params">(*pollDesc, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	pd := pollcache.alloc()</span><br><span class="line">	lock(&amp;pd.lock)</span><br><span class="line">	<span class="keyword">if</span> pd.wg != <span class="number">0</span> &amp;&amp; pd.wg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">"runtime: blocked write on free polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pd.rg != <span class="number">0</span> &amp;&amp; pd.rg != pdReady &#123;</span><br><span class="line">		throw(<span class="string">"runtime: blocked read on free polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pd.fd = fd</span><br><span class="line">	pd.closing = <span class="literal">false</span></span><br><span class="line">	pd.everr = <span class="literal">false</span></span><br><span class="line">	pd.rseq++</span><br><span class="line">	pd.rg = <span class="number">0</span></span><br><span class="line">	pd.rd = <span class="number">0</span></span><br><span class="line">	pd.wseq++</span><br><span class="line">	pd.wg = <span class="number">0</span></span><br><span class="line">	pd.wd = <span class="number">0</span></span><br><span class="line">	pd.self = pd</span><br><span class="line">	unlock(&amp;pd.lock)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> errno <span class="keyword">int32</span></span><br><span class="line">	errno = netpollopen(fd, pd)</span><br><span class="line">	<span class="keyword">return</span> pd, <span class="keyword">int</span>(errno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollopen</span><span class="params">(fd <span class="keyword">uintptr</span>, pd *pollDesc)</span> <span class="title">int32</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ev epollevent</span><br><span class="line">	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">	<span class="keyword">return</span> -epollctl(epfd, _EPOLL_CTL_ADD, <span class="keyword">int32</span>(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="park-goroutine"><a href="#park-goroutine" class="headerlink" title="park goroutine"></a>park goroutine</h2><p><code>netpoll</code> accept socket 的工作流程如下：</p>
<blockquote>
<ol>
<li>服务端的 netFD 在 <code>listen</code> 时会创建 epoll 的实例，并将 listenerFD 加入 epoll 的事件队列</li>
<li>netFD 在 <code>accept</code> 时将返回的 connFD 也加入 epoll 的事件队列</li>
<li>netFD 在读写时出现 <code>syscall.EAGAIN</code> 错误，通过 pollDesc 的 <code>waitRead</code> 方法将当前的 goroutine park 住，直到 ready，从 pollDesc 的 <code>waitRead</code> 中返回</li>
</ol>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">accept</span><span class="params">()</span> <span class="params">(netfd *netFD, err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 调用 poll.FD 的 Accept 方法接受新的 socket 连接，返回 socket 的 fd</span></span><br><span class="line">	d, rsa, errcall, err := fd.pfd.Accept()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> errcall != <span class="string">""</span> &#123;</span><br><span class="line">			err = wrapSyscallError(errcall, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 以 socket fd 构造一个新的 netFD，代表这个新的 socket</span></span><br><span class="line">	<span class="keyword">if</span> netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		poll.CloseFunc(d)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 调用 netFD 的 init 方法完成初始化</span></span><br><span class="line">	<span class="keyword">if</span> err = netfd.init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		netfd.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)</span><br><span class="line">	netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))</span><br><span class="line">	<span class="keyword">return</span> netfd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>netFD.accept</code> 方法里会再调用 <code>poll.FD.Accept</code> ，最后会使用 Linux 的系统调用 <code>accept</code> 来完成新连接的接收，并且会把 accept 的 socket 设置成非阻塞 I/O 模式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, syscall.Sockaddr, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := fd.readLock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> fd.readUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := fd.pd.prepareRead(fd.isFile); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, <span class="string">""</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 linux 系统调用 accept 接收新连接，创建对应的 socket</span></span><br><span class="line">		s, rsa, errcall, err := accept(fd.Sysfd)</span><br><span class="line">    <span class="comment">// 因为 listener fd 在创建的时候已经设置成非阻塞的了</span></span><br><span class="line">    <span class="comment">// 所以 accept 方法会直接返回，不管有没有新连接到来；如果 err == nil 则表示正常建立新连接，直接返回</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> s, rsa, <span class="string">""</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 如果 err != nil，则判断 err == syscall.EAGAIN，符合条件则进入 pollDesc.waitRead 方法</span></span><br><span class="line">		<span class="keyword">switch</span> err &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.EINTR:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		<span class="keyword">case</span> syscall.EAGAIN:</span><br><span class="line">			<span class="keyword">if</span> fd.pd.pollable() &#123;</span><br><span class="line">        <span class="comment">// 如果当前没有发生期待的 I/O 事件，那么 waitRead 会通过 park goroutine 让逻辑 block 在这里</span></span><br><span class="line">				<span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">continue</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> syscall.ECONNABORTED:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">nil</span>, errcall, err</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pollDesc.waitRead</code> 方法主要负责检测当前这个 pollDesc 的上层 netFD 对应的 fd 是否有『期待的』I/O 事件发生，如果有就直接返回，否则就 park 住当前的 goroutine 并持续等待直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，然后它就会返回到外层的 for 循环，让 goroutine 继续执行逻辑。</p>
<p>poll.FD.Accept() 返回之后，会构造一个对应这个新 socket 的 netFD，然后调用 init() 方法完成初始化，这个 init 过程和前面 net.Listen() 是一样的，然后把这个 socket fd 注册到 listener 的 epoll 实例的事件队列中去，等待 I/O 事件。</p>
<p><code>pollDesc.waitRead</code> 内部调用了 <code>poll.runtime_pollWait</code> –&gt; <code>runtime.poll_runtime_pollWait</code> 来达成无 I/O 事件时 park 住 goroutine 的目的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	errcode := netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line">	<span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">		<span class="keyword">return</span> errcode</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> GOOS == <span class="string">"solaris"</span> || GOOS == <span class="string">"illumos"</span> || GOOS == <span class="string">"aix"</span> &#123;</span><br><span class="line">		netpollarm(pd, mode)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 进入 netpollblock 并且判断是否有期待的 I/O 事件发生，这里的 for 循环是为了一直等到 io ready</span></span><br><span class="line">	<span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">		errcode = netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line">		<span class="keyword">if</span> errcode != pollNoError &#123;</span><br><span class="line">			<span class="keyword">return</span> errcode</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pollNoError</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>netpollblock 判断是否有期待的 I/O 事件发生：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblock</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>, waitio <span class="keyword">bool</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// gpp 保存的是 goroutine 的数据结构 g，这里会根据 mode 的值决定是 rg 还是 wg，</span></span><br><span class="line">	<span class="comment">// rg 和 wg 是用来保存等待 I/O 就绪的 gorouine 的，后面调用 gopark 之后，会把当前的 goroutine 的抽象数据结构 g 存入 gpp 这个指针，也就是 rg 或者 wg</span></span><br><span class="line">	gpp := &amp;pd.rg</span><br><span class="line">	<span class="keyword">if</span> mode == <span class="string">'w'</span> &#123;</span><br><span class="line">		gpp = &amp;pd.wg</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个 for 循环是为了等待 io ready 或者 io wait</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		old := *gpp</span><br><span class="line">		<span class="comment">// gpp == pdReady 表示此时已有期待的 I/O 事件发生，可以直接返回 unblock 当前 goroutine 并执行响应的 I/O 操作</span></span><br><span class="line">		<span class="keyword">if</span> old == pdReady &#123;</span><br><span class="line">			*gpp = <span class="number">0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> old != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"runtime: double wait"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果没有期待的 I/O 事件发生，则通过原子操作把 gpp 的值置为 pdWait 并退出 for 循环</span></span><br><span class="line">		<span class="keyword">if</span> atomic.Casuintptr(gpp, <span class="number">0</span>, pdWait) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// waitio 此时是 false，netpollcheckerr 方法会检查当前 pollDesc 对应的 fd 是否是正常的，</span></span><br><span class="line">	<span class="comment">// 通常来说  netpollcheckerr(pd, mode) == 0 是成立的，所以这里会执行 gopark</span></span><br><span class="line">	<span class="comment">// 把当前 goroutine 给 park 住，直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，</span></span><br><span class="line">	<span class="comment">// 然后 unpark 返回，在 gopark 内部会把当前 goroutine 的抽象数据结构 g 存入</span></span><br><span class="line">	<span class="comment">// gpp(pollDesc.rg/pollDesc.wg) 指针里，以便在后面的 netpoll 函数取出 pollDesc 之后，</span></span><br><span class="line">	<span class="comment">// 把 g 添加到链表里返回，接着重新调度 goroutine</span></span><br><span class="line">	<span class="keyword">if</span> waitio || netpollcheckerr(pd, mode) == <span class="number">0</span> &#123;</span><br><span class="line">		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, <span class="number">5</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	old := atomic.Xchguintptr(gpp, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> old &gt; pdWait &#123;</span><br><span class="line">		throw(<span class="string">"runtime: corrupted polldesc"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> old == pdReady</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gopark 会停住当前的 goroutine 并且调用传递进来的回调函数 unlockf，从 netpollblock函数 我们可以知道这个函数是 netpollblockcommit。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gopark</span><span class="params">(unlockf <span class="keyword">func</span>(*g, unsafe.Pointer)</span> <span class="title">bool</span>, <span class="title">lock</span> <span class="title">unsafe</span>.<span class="title">Pointer</span>, <span class="title">reason</span> <span class="title">waitReason</span>, <span class="title">traceEv</span> <span class="title">byte</span>, <span class="title">traceskip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> reason != waitReasonSleep &#123;</span><br><span class="line">		checkTimeouts()</span><br><span class="line">	&#125;</span><br><span class="line">	mp := acquirem()</span><br><span class="line">	gp := mp.curg</span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line">	<span class="keyword">if</span> status != _Grunning &amp;&amp; status != _Gscanrunning &#123;</span><br><span class="line">		throw(<span class="string">"gopark: bad g status"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mp.waitlock = lock</span><br><span class="line">	mp.waitunlockf = unlockf</span><br><span class="line">	gp.waitreason = reason</span><br><span class="line">	mp.waittraceev = traceEv</span><br><span class="line">	mp.waittraceskip = traceskip</span><br><span class="line">	releasem(mp)</span><br><span class="line">	<span class="comment">// gopark 最终会调用 park_m，在这个函数内部会调用 unlockf，也就是 netpollblockcommit，</span></span><br><span class="line">	<span class="comment">// 然后会把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</span></span><br><span class="line">	mcall(park_m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">park_m</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	casgstatus(gp, _Grunning, _Gwaiting)</span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fn := _g_.m.waitunlockf; fn != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 调用 netpollblockcommit，把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里</span></span><br><span class="line">		ok := fn(gp, _g_.m.waitlock)</span><br><span class="line">		_g_.m.waitunlockf = <span class="literal">nil</span></span><br><span class="line">		_g_.m.waitlock = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			execute(gp, <span class="literal">true</span>) <span class="comment">// Schedule it back, never returns.</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netpollblockcommit 在 gopark 函数里被调用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollblockcommit</span><span class="params">(gp *g, gpp unsafe.Pointer)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过原子操作把当前 goroutine 抽象的数据结构 g，也就是这里的参数 gp 存入 gpp 指针，</span></span><br><span class="line">	<span class="comment">// 此时 gpp 的值是 pollDesc 的 rg 或者 wg 指针</span></span><br><span class="line">	r := atomic.Casuintptr((*<span class="keyword">uintptr</span>)(gpp), pdWait, <span class="keyword">uintptr</span>(unsafe.Pointer(gp)))</span><br><span class="line">	<span class="keyword">if</span> r &#123;</span><br><span class="line">		atomic.Xadd(&amp;netpollWaiters, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll-wait-——-netpoll"><a href="#epoll-wait-——-netpoll" class="headerlink" title="epoll_wait —— netpoll"></a>epoll_wait —— netpoll</h2><p>前面已经从源码的层面分析完了 netpoll 是如何通过 park goroutine 从而达到阻塞 Accept/Read/Write 的效果，而通过调用 gopark，goroutine 会被放置在某个等待队列中，这里是放到了 epoll 的 “interest list” 里，底层数据结构是由红黑树实现的 <code>eventpoll.rbr</code>，此时 G 的状态由 <code>_Grunning</code>为<code>_Gwaitting</code> ，因此 G 必须被手动唤醒(通过 goready )，否则会丢失任务，应用层阻塞通常使用这种方式。</p>
<p><img src="/images/io-3.png" alt="io"></p>
<blockquote>
<p>首先，client 连接 server 的时候，listener 通过 accept 调用接收新 connection，每一个新 connection 都启动一个 goroutine 处理，accept 调用会把该 connection 的 fd 连带所在的 goroutine 上下文信息封装注册到 epoll 的监听列表里去，当 goroutine 调用 <code>conn.Read</code> 或者 <code>conn.Write</code> 等需要阻塞等待的函数时，会被 <code>gopark</code> 给封存起来并使之休眠，让 P 去执行本地调度队列里的下一个可执行的 goroutine，往后 Go scheduler 会在循环调度的 <code>runtime.schedule()</code> 函数以及 sysmon 监控线程中调用 <code>runtime.netpoll</code> 以获取可运行的 goroutine 列表并通过调用 injectglist 把剩下的 g 放入全局调度队列或者当前 P 本地调度队列去重新执行。</p>
<p>那么当 I/O 事件发生之后，netpoller 通过 <code>runtime.netpoll</code>唤醒那些在 I/O wait 的 goroutine。</p>
</blockquote>
<p><code>runtime.netpoll</code> 的核心逻辑是：</p>
<blockquote>
<ol>
<li>根据调用方的入参 delay，设置对应的调用 <code>epollwait</code> 的 timeout 值；</li>
<li>调用 <code>epollwait</code> 等待发生了可读/可写事件的 fd；</li>
<li>循环 <code>epollwait</code> 返回的事件列表，处理对应的事件类型， 组装可运行的 goroutine 链表并返回。</li>
</ol>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 轮询网络并返回一组已经准备就绪的 Goroutine，传入的参数会决定它的行为；</span></span><br><span class="line"><span class="comment">// 如果参数小于 0，无限期等待文件描述符就绪；</span></span><br><span class="line"><span class="comment">// 如果参数等于 0，非阻塞地轮询网络；</span></span><br><span class="line"><span class="comment">// 如果参数大于 0，阻塞特定时间轮询网络；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件，等于: int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpoll</span><span class="params">(delay <span class="keyword">int64</span>)</span> <span class="title">gList</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> epfd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> waitms <span class="keyword">int32</span></span><br><span class="line">	<span class="comment">// 根据调用方的入参 delay，设置对应的调用 epollwait 的 timeout 值；</span></span><br><span class="line">	<span class="keyword">if</span> delay &lt; <span class="number">0</span> &#123;</span><br><span class="line">		waitms = <span class="number">-1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay == <span class="number">0</span> &#123;</span><br><span class="line">		waitms = <span class="number">0</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e6</span> &#123;</span><br><span class="line">		waitms = <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> delay &lt; <span class="number">1e15</span> &#123;</span><br><span class="line">		waitms = <span class="keyword">int32</span>(delay / <span class="number">1e6</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		waitms = <span class="number">1e9</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> events [<span class="number">128</span>]epollevent</span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">// 调用 epollwait 等待发生了可读/可写事件的 fd；</span></span><br><span class="line">	<span class="comment">// 循环 epollwait 返回的事件列表，处理对应的事件类型， 组装可运行的 goroutine 链表并返回。</span></span><br><span class="line">	n := epollwait(epfd, &amp;events[<span class="number">0</span>], <span class="keyword">int32</span>(<span class="built_in">len</span>(events)), waitms)</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n != -_EINTR &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">"runtime: epollwait on fd"</span>, epfd, <span class="string">"failed with"</span>, -n)</span><br><span class="line">			throw(<span class="string">"runtime: netpoll failed"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> waitms &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gList&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">goto</span> retry</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// toRun 是一个 g 的链表，存储要恢复的 goroutines，最后返回给调用方</span></span><br><span class="line">	<span class="keyword">var</span> toRun gList</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; n; i++ &#123;</span><br><span class="line">		ev := &amp;events[i]</span><br><span class="line">		<span class="keyword">if</span> ev.events == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Go scheduler 在调用 findrunnable() 寻找 goroutine 去执行的时候，</span></span><br><span class="line">		<span class="comment">// 在调用 netpoll 之时会检查当前是否有其他线程同步阻塞在 netpoll，</span></span><br><span class="line">		<span class="comment">// 若是，则调用 netpollBreak 来唤醒那个线程，避免它长时间阻塞</span></span><br><span class="line">		<span class="keyword">if</span> *(**<span class="keyword">uintptr</span>)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd &#123;</span><br><span class="line">			<span class="keyword">if</span> ev.events != _EPOLLIN &#123;</span><br><span class="line">				<span class="built_in">println</span>(<span class="string">"runtime: netpoll: break fd ready for"</span>, ev.events)</span><br><span class="line">				throw(<span class="string">"runtime: netpoll: break fd ready for something unexpected"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> delay != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">var</span> tmp [<span class="number">16</span>]<span class="keyword">byte</span></span><br><span class="line">				read(<span class="keyword">int32</span>(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[<span class="number">0</span>])), <span class="keyword">int32</span>(<span class="built_in">len</span>(tmp)))</span><br><span class="line">				atomic.Store(&amp;netpollWakeSig, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断发生的事件类型，读类型或者写类型等，然后给 mode 复制相应的值，</span></span><br><span class="line">		<span class="comment">// mode 用来决定从 pollDesc 里的 rg 还是 wg 里取出 goroutine</span></span><br><span class="line">		<span class="keyword">var</span> mode <span class="keyword">int32</span></span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">'r'</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != <span class="number">0</span> &#123;</span><br><span class="line">			mode += <span class="string">'w'</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> mode != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 取出保存在 epollevent 里的 pollDesc</span></span><br><span class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</span><br><span class="line">			pd.everr = <span class="literal">false</span></span><br><span class="line">			<span class="keyword">if</span> ev.events == _EPOLLERR &#123;</span><br><span class="line">				pd.everr = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 调用 netpollready，传入就绪 fd 的 pollDesc，</span></span><br><span class="line">			<span class="comment">// 把 fd 对应的 goroutine 添加到链表 toRun 中</span></span><br><span class="line">			netpollready(&amp;toRun, pd, mode)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> toRun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go 在多种场景下都可能会调用 <code>netpoll</code> 检查文件描述符状态，<code>netpoll</code> 里会调用 <code>epoll_wait</code> 从 epoll 的 <code>eventpoll.rdllist</code> 就绪双向链表返回，从而得到 I/O 就绪的 socket fd 列表，并根据取出最初调用 <code>epoll_ctl</code> 时保存的上下文信息，恢复 <code>g</code>。所以执行完<code>netpoll</code> 之后，会返回一个就绪 fd 列表对应的 goroutine 链表，接下来将就绪的 goroutine 通过调用 <code>injectglist</code> 加入到全局调度队列或者 P 的本地调度队列中，启动 M 绑定 P 去执行。</p>
<p>具体调用 <code>netpoll</code> 的地方，首先在 Go runtime scheduler 循环调度 goroutines 之时就有可能会调用 <code>netpoll</code> 获取到已就绪的 fd 对应的 goroutine 来调度执行。</p>
<p>首先 Go scheduler 的核心方法 <code>runtime.schedule()</code> 里会调用一个叫 <code>runtime.findrunable()</code> 的方法获取可运行的 goroutine 来执行，而在 <code>runtime.findrunable()</code> 方法里就调用了 <code>runtime.netpoll</code> 获取已就绪的 fd 列表对应的 goroutine 列表：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ...</span><br><span class="line">   </span><br><span class="line"> <span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 从本地运行队列和全局运行队列都没有找到需要运行的 goroutine，</span></span><br><span class="line">		<span class="comment">// 调用 findrunnable 函数从其它工作线程的运行队列中偷取，如果偷不到，则当前工作线程进入睡眠</span></span><br><span class="line">		<span class="comment">// 直到获取到 runnable goroutine 之后 findrunnable 函数才会返回。</span></span><br><span class="line"> 		gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从其他地方找 goroutine 来执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 取当前指向的 g，也就是 g0</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	now, pollUntil, _ := checkTimers(_p_, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		<span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// local runq</span></span><br><span class="line">	<span class="comment">// 从本地队列获取</span></span><br><span class="line">	<span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gp, inheritTime</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// global runq</span></span><br><span class="line">	<span class="comment">// 从全局队列获取</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Poll network.</span></span><br><span class="line">	<span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line">	<span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line">	<span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line">	<span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line">	<span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line">	<span class="comment">// anyway.</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">			gp := list.pop()</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Steal work from other P's.</span></span><br><span class="line">	procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">	ranTimer := <span class="literal">false</span></span><br><span class="line">	<span class="comment">// 如果有很多工作线程在找工作，那我就停下休息。避免消耗太多 CPU</span></span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">		<span class="comment">// 设置自旋状态为 true</span></span><br><span class="line">		_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// 自旋状态数加 1</span></span><br><span class="line">		atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> stealTries = <span class="number">4</span></span><br><span class="line">	<span class="comment">// 从其它 p 的本地运行队列盗取 goroutine</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; stealTries; i++ &#123;</span><br><span class="line">		stealTimersOrRunNextG := i == stealTries<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			p2 := allp[enum.position()]</span><br><span class="line">			<span class="keyword">if</span> _p_ == p2 &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> stealTimersOrRunNextG &amp;&amp; timerpMask.read(enum.position()) &#123;</span><br><span class="line">				tnow, w, ran := checkTimers(p2, now)</span><br><span class="line">				now = tnow</span><br><span class="line">				<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">					pollUntil = w</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> ran &#123;</span><br><span class="line">					<span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">						<span class="keyword">return</span> gp, inheritTime</span><br><span class="line">					&#125;</span><br><span class="line">					ranTimer = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Don't bother to attempt to steal if p2 is idle.</span></span><br><span class="line">			<span class="keyword">if</span> !idlepMask.read(enum.position()) &#123;</span><br><span class="line">				<span class="keyword">if</span> gp := runqsteal(_p_, p2, stealTimersOrRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ranTimer &#123;</span><br><span class="line">		<span class="comment">// Running a timer may have made some goroutine ready.</span></span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">		<span class="keyword">if</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">			_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">			gp := node.gp.ptr()</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	delta := <span class="keyword">int64</span>(<span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">if</span> pollUntil != <span class="number">0</span> &#123;</span><br><span class="line">		delta = pollUntil - now</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	gp, otherReady := beforeIdle(delta)</span><br><span class="line">	<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> otherReady &#123;</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	allpSnapshot := allp</span><br><span class="line">	idlepMaskSnapshot := idlepMask</span><br><span class="line">	timerpMaskSnapshot := timerpMask</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return P and block</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 当前工作线程解除与 p 之间的绑定，准备去休眠</span></span><br><span class="line">	<span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">		throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把 p 放入空闲队列</span></span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	wasSpinning := _g_.m.spinning</span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		<span class="comment">// m 即将睡眠，不再处于自旋</span></span><br><span class="line">		_g_.m.spinning = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 休眠之前再检查一下所有的 p，看一下是否有工作要做</span></span><br><span class="line">	<span class="keyword">for</span> id, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">		<span class="keyword">if</span> !idlepMaskSnapshot.read(<span class="keyword">uint32</span>(id)) &amp;&amp; !runqempty(_p_) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">					_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">					atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> id, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">		<span class="keyword">if</span> timerpMaskSnapshot.read(<span class="keyword">uint32</span>(id)) &#123;</span><br><span class="line">			w := nobarrierWakeTime(_p_)</span><br><span class="line">			<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">				pollUntil = w</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> pollUntil != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> now == <span class="number">0</span> &#123;</span><br><span class="line">			now = nanotime()</span><br><span class="line">		&#125;</span><br><span class="line">		delta = pollUntil - now</span><br><span class="line">		<span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;</span><br><span class="line">			delta = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;gcBlackenEnabled) != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">var</span> node *gcBgMarkWorkerNode</span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &#123;</span><br><span class="line">				node = (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())</span><br><span class="line">				<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">					pidleput(_p_)</span><br><span class="line">					_p_ = <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pidleput(_p_)</span><br><span class="line">				_p_ = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">			acquirep(_p_)</span><br><span class="line">			<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">				_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">				atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Run the idle worker.</span></span><br><span class="line">			_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">			gp := node.gp.ptr()</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poll network</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; (atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> || pollUntil != <span class="number">0</span>) &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		atomic.Store64(&amp;sched.pollUntil, <span class="keyword">uint64</span>(pollUntil))</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> faketime != <span class="number">0</span> &#123;</span><br><span class="line">			delta = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		list := netpoll(delta) <span class="comment">// block until new work is available</span></span><br><span class="line">		atomic.Store64(&amp;sched.pollUntil, <span class="number">0</span>)</span><br><span class="line">		atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">		<span class="keyword">if</span> faketime != <span class="number">0</span> &amp;&amp; list.empty() &#123;</span><br><span class="line">			stopm()</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			acquirep(_p_)</span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				gp := list.pop()</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">				<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">					traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">				_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">				atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">goto</span> top</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> pollUntil != <span class="number">0</span> &amp;&amp; netpollinited() &#123;</span><br><span class="line">		pollerPollUntil := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.pollUntil))</span><br><span class="line">		<span class="keyword">if</span> pollerPollUntil == <span class="number">0</span> || pollerPollUntil &gt; pollUntil &#123;</span><br><span class="line">			netpollBreak()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 休眠</span></span><br><span class="line">	stopm()</span><br><span class="line">	<span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外， <code>sysmon</code> 监控线程会在循环过程中检查距离上一次 <code>runtime.netpoll</code> 被调用是否超过了 10ms，若是则会去调用它拿到可运行的 goroutine 列表并通过调用 injectglist 把 g 列表放入全局调度队列或者当前 P 本地调度队列等待被执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  ...</span><br><span class="line">	lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">			list := netpoll(<span class="number">0</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go runtime 在程序启动的时候会创建一个独立的 M 作为监控线程，叫 <code>sysmon</code> ，这个线程为系统级的 daemon 线程，无需 P 即可运行， <code>sysmon</code> 每 20us~10ms 运行一次。 <code>sysmon</code> 中以轮询的方式执行以下操作：</p>
<blockquote>
<ol>
<li>以非阻塞的方式调用 <code>runtime.netpoll</code> ，从中找出能从网络 I/O 中唤醒的 g 列表，并通过调用 injectglist 把 g 列表放入全局调度队列或者当前 P 本地调度队列等待被执行，调度触发时，有可能从这个全局 runnable 调度队列获取 g。然后再循环调用 <code>startm</code> ，直到所有 P 都不处于 <code>_Pidle</code> 状态。</li>
<li>调用 <code>retake</code> ，抢占长时间处于 <code>_Psyscall</code> 状态的 P。</li>
</ol>
</blockquote>
<p>综上，Go 借助于 epoll 和 runtime scheduler 等的帮助，设计出了自己的 I/O 多路复用 netpoller，成功地让 <code>Listener.Accept</code> / <code>conn.Read</code> / <code>conn.Write</code> 等方法从开发者的角度看来是同步模式。</p>
<h2 id="Go-netpoller-设计特点"><a href="#Go-netpoller-设计特点" class="headerlink" title="Go netpoller 设计特点"></a>Go netpoller 设计特点</h2><p>通过前面对源码的分析，我们现在知道 Go netpoller 依托于 runtime scheduler，为开发者提供了一种强大的同步网络编程模式；然而，Go netpoller 存在的意义却远不止于此，Go netpoller I/O 多路复用搭配 Non-blocking I/O 而打造出来的这个原生网络模型，它最大的价值是把网络 I/O 的控制权牢牢掌握在 Go 自己的 runtime 里。</p>
<p>G 在运行过程中如果被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，那么就会创建一个新的 M。当阻塞在 system call 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为 <code>_Grunnable</code> 并把它放入全局的 runqueue 中等待调度，之前的那个 sleep 的 M 将再次进入 sleep。</p>
<p>现在清楚为什么 netpoll 为什么一定要使用非阻塞 I/O 了吧？就是为了避免让操作网络 I/O 的 goroutine 陷入到系统调用从而进入内核态，因为一旦进入内核态，整个程序的控制权就会发生转移(到内核)，不再属于用户进程了，那么也就无法借助于 Go 强大的 runtime scheduler 来调度业务程序的并发了；而有了 netpoll 之后，借助于非阻塞 I/O ，G 就再也不会因为系统调用的读写而 (长时间) 陷入内核态，当 G 被阻塞在某个 network I/O 操作上时，实际上它不是因为陷入内核态被阻塞住了，而是被 Go runtime 调用 gopark 给 park 住了，此时 G 会被放置到某个 wait queue 中，而 M 会尝试运行下一个 <code>_Grunnable</code> 的 G，如果此时没有 <code>_Grunnable</code> 的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available，在 epoll 的 <code>eventpoll.rdr</code> 中等待的 G 会被放到 <code>eventpoll.rdllist</code> 链表里并通过 <code>netpoll</code> 中的 <code>epoll_wait</code> 系统调用返回放置到全局调度队列或者 P 的本地调度队列，标记为 <code>_Grunnable</code> ，等待 P 绑定 M 恢复执行。</p>
<h2 id="Go-netpoller-问题"><a href="#Go-netpoller-问题" class="headerlink" title="Go netpoller 问题"></a>Go netpoller 问题</h2><p>Go netpoller 的设计不可谓不精巧、性能也不可谓不高。因此 Go 的网络编程模式是及其简洁高效的，然而，没有任何一种设计和架构是完美的， <code>goroutine-per-connection</code> 这种模式虽然简单高效，但是在某些极端的场景下也会暴露出问题：goroutine 虽然非常轻量，它的自定义栈内存初始值仅为 2KB，后面按需扩容；海量连接的业务场景下， <code>goroutine-per-connection</code> ，此时 goroutine 数量以及消耗的资源就会呈线性趋势暴涨，虽然 Go scheduler 内部做了 g 的缓存链表，可以一定程度上缓解高频创建销毁 goroutine 的压力，但是对于瞬时性暴涨的长连接场景就无能为力了，大量的 goroutines 会被不断创建出来，从而对 Go runtime scheduler 造成极大的调度压力和侵占系统资源，然后资源被侵占又反过来影响 Go scheduler 的调度，进而导致性能下降。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://strikefreedom.top/go-netpoll-io-multiplexing-reactor" target="_blank" rel="noopener">strikefreedom.top blog</a></li>
<li><a href="https://morsmachine.dk/netpoller" target="_blank" rel="noopener">morsing大神</a></li>
<li><a href="https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/#.YSWyGdMzZAb" target="_blank" rel="noopener">devarea.com I/O多路复用</a></li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/" target="_blank" rel="noopener">Drabness blog</a></li>
</ol>

      
    </div>
    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <div>
          
            
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2021/08/24/IOMultiplexing/">深入理解Golang网络轮询器NetPoller</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Wxning 的个人博客">Wxning</a></p>
  <p><span>发布时间:</span>2021年08月24日 - 17:08</p>
  <p><span>最后更新:</span>2021年08月30日 - 17:08</p>
  <p><span>原始链接:</span><a href="/2021/08/24/IOMultiplexing/" title="深入理解Golang网络轮询器NetPoller">http://yoursite.com/2021/08/24/IOMultiplexing/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://yoursite.com/2021/08/24/IOMultiplexing/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({
          title: "",
          text: '复制成功',
          icon: "success",
          showConfirmButton: true
          });
    });
    });
</script>


          
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/golang/" rel="tag"># golang</a>
          
            <a href="/tags/golang-source/" rel="tag"># golang source</a>
          
            <a href="/tags/network/" rel="tag"># network</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/28/channel/" rel="next" title="深入理解 channel">
                <i class="fa fa-chevron-left"></i> 深入理解 channel
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/09/13/trace/" rel="prev" title="分布式链路追踪">
                分布式链路追踪 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTE2Ny8yMTY4NA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Wxning">
            
              <p class="site-author-name" itemprop="name">Wxning</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wxning1107" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞I-O与非阻塞I-O"><span class="nav-number">1.</span> <span class="nav-text">阻塞I/O与非阻塞I/O</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O多路复用"><span class="nav-number">2.</span> <span class="nav-text">I/O多路复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#select-amp-poll"><span class="nav-number">3.</span> <span class="nav-text">select &amp; poll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll"><span class="nav-number">4.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#go-netPoller"><span class="nav-number">5.</span> <span class="nav-text">go netPoller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络轮询器接口"><span class="nav-number">6.</span> <span class="nav-text">网络轮询器接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构"><span class="nav-number">7.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现原理"><span class="nav-number">8.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化"><span class="nav-number">9.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#park-goroutine"><span class="nav-number">10.</span> <span class="nav-text">park goroutine</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#epoll-wait-——-netpoll"><span class="nav-number">11.</span> <span class="nav-text">epoll_wait —— netpoll</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-netpoller-设计特点"><span class="nav-number">12.</span> <span class="nav-text">Go netpoller 设计特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go-netpoller-问题"><span class="nav-number">13.</span> <span class="nav-text">Go netpoller 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">14.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wxning</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
