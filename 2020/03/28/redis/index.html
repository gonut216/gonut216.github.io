<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="redis,数据库,">










<meta name="description" content="Redis单线程优势Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 NoSQL数据库的产生就是为了解决大规模数据集合，多重数据种类带来的挑战。 Redis 与其他 key - value 缓存产品有以下三个特点：  Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的">
<meta name="keywords" content="redis,数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="redis知识汇总">
<meta property="og:url" content="http://yoursite.com/2020/03/28/redis/index.html">
<meta property="og:site_name" content="Wxning">
<meta property="og:description" content="Redis单线程优势Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 NoSQL数据库的产生就是为了解决大规模数据集合，多重数据种类带来的挑战。 Redis 与其他 key - value 缓存产品有以下三个特点：  Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/redis-16.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-17.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-18.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-19.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-24.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-25.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-13.png">
<meta property="og:image" content="http://yoursite.com/images/redis-20.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-21.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-22.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-6.png">
<meta property="og:image" content="http://yoursite.com/images/redis-23.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-14.png">
<meta property="og:image" content="http://yoursite.com/images/redis-26.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-73.png">
<meta property="og:image" content="http://yoursite.com/images/redis-74.png">
<meta property="og:image" content="http://yoursite.com/images/redis-75.png">
<meta property="og:image" content="http://yoursite.com/images/redis-76.png">
<meta property="og:image" content="http://yoursite.com/images/redis-77.png">
<meta property="og:image" content="http://yoursite.com/images/redis-27.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-31.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-30.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-28.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-29.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-32.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-33.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-34.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-4.png">
<meta property="og:image" content="http://yoursite.com/images/redis-5.png">
<meta property="og:image" content="http://yoursite.com/images/redis-7.png">
<meta property="og:image" content="http://yoursite.com/images/redis-35.jpg">
<meta property="og:image" content="http://yoursite.com/images/redis-36.jpg">
<meta property="og:updated_time" content="2022-02-26T08:26:51.500Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis知识汇总">
<meta name="twitter:description" content="Redis单线程优势Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。 NoSQL数据库的产生就是为了解决大规模数据集合，多重数据种类带来的挑战。 Redis 与其他 key - value 缓存产品有以下三个特点：  Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的">
<meta name="twitter:image" content="http://yoursite.com/images/redis-16.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/28/redis/">





  <title>redis知识汇总 | Wxning</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/wxning1107" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wxning</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-个人简历">
          <a href="/个人简历/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            个人简历
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/28/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wxning">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wxning">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis知识汇总</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-28T23:07:31+08:00">
                2020-03-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Redis单线程优势"><a href="#Redis单线程优势" class="headerlink" title="Redis单线程优势"></a>Redis单线程优势</h2><p><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a> 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。</p>
<p>NoSQL数据库的产生就是为了解决大规模数据集合，多重数据种类带来的挑战。</p>
<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<p>Redis优势：</p>
<ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<p>首先，我要和你厘清一个事实，我们通常说，Redis 是单线程，主要是指 Redis 的网络 IO<br>和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。<br>但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执<br>行的。</p>
<h3 id="为什么不用多线程？"><a href="#为什么不用多线程？" class="headerlink" title="为什么不用多线程？"></a>为什么不用多线程？</h3><p>使用多线程，可以增加系统吞吐率，或是可以增加系统扩展性。但是，多线程编程模式面临的共享资源的并发访问控制问题。系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。</p>
<h3 id="单线程-Redis-为什么那么快？"><a href="#单线程-Redis-为什么那么快？" class="headerlink" title="单线程 Redis 为什么那么快？"></a>单线程 Redis 为什么那么快？</h3><p>通常来说，单线程的处理能力要比多线程差很多，但是 Redis 却能使用单线程模型达到每<br>秒数十万级别的处理能力，这是为什么呢？其实，这是 Redis 多方面设计选择的一个综合<br>结果。<br>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希<br>表和跳表，这是它实现高性能的一个重要原因。<br>另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>
<h2 id="redis数据类型"><a href="#redis数据类型" class="headerlink" title="redis数据类型"></a>redis数据类型</h2><p>redis数据类型与底层数据结构对应关系：<br><img src="/images/redis-16.jpg" alt="redis-1"></p>
<p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。<br><img src="/images/redis-17.jpg" alt="redis-1"></p>
<p>hash表的操作时间复杂度是O(1)，但是当往 Redis 中<br>写入大量数据后，就可能发现操作有时候会突然变慢了。这是因为忽略了一个潜在的风险点，那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。<br>Redis 解决哈希冲突的方式，就是链式哈希。链式哈希就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。<br>如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链<br>过长，进而导致这个链上的元素查找耗时长，效率降低。所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。<br>其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：<code>哈希表 1</code> 和<code>哈希表 2</code>。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li>
<li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li>
<li>释放哈希表 1 的空间。</li>
</ol>
<p>到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来<br>的哈希表 1 留作下一次 rehash 扩容备用。这个过程第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了渐进式 rehash。<br>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求<br>时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝<br>到哈希表 2 中。等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：<br><img src="/images/redis-18.jpg" alt="redis-1"></p>
<p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操<br>作，保证了数据的快速访问。<br><img src="/images/redis-19.jpg" alt="redis-1"></p>
<blockquote>
<p>第一，单元素操作，是指每一种集合类型对单个数据实现的增删改查操作。例如，Hash 类<br>型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操<br>作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操<br>作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、<br>SREM、SRANDMEMBER 复杂度也是 O(1)。Hash 类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</p>
</blockquote>
<blockquote>
<p>第二，范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据，比如 Hash<br>类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List<br>类型的 LRANGE 和 ZSet 类型的 ZRANGE。这类操作的复杂度一般是 O(N)，比较耗时，<br>我们应该尽量避免。不过，Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于 HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</p>
</blockquote>
<blockquote>
<p>第三，统计操作，是指集合类型对集合中所有元素个数的记录，例如 LLEN 和 SCARD。这<br>类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数<br>据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p>
</blockquote>
<blockquote>
<p>第四，例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头<br>和表尾的偏移量。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操<br>作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂<br>度也只有 O(1)，可以实现快速操作。</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>简介</th>
<th>特性</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>String(字符串)</td>
<td>二进制安全</td>
<td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td>
<td>做简单的键值对缓存。适合最简单的k-v存储，类似于memcached的存储结构，短信验证码，配置信息等，就用这种类型来存储。</td>
</tr>
<tr>
<td>Hash(字典)</td>
<td>键值对集合</td>
<td>适合存储对象，并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td>
<td>1，存储，读取修改用户属性。2，结构化的数据，比如一个对象。3，一般key为ID或者唯一标示，value对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</td>
</tr>
<tr>
<td>List(列表)</td>
<td>链表(双向链表)</td>
<td>增删快，提供了操作某一段元素的API</td>
<td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列 3，存储一些列表型的数据结构，类似粉丝列表，文章评论列表之类。4，因为list是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为list是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</td>
</tr>
<tr>
<td>Set(集合)</td>
<td>哈希表实现,元素不重复</td>
<td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td>
<td>1、共同好友（交集并集差级操作，两个人的粉丝列表整一个交集） 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐。4，可以简单的理解为ID-List的模式，如微博中一个人有哪些好友，set最牛的地方在于，可以对两个set提供交集、并集、差集操作。例如：查找两个人共同的好友等。</td>
</tr>
<tr>
<td>Sorted Set(有序集合)</td>
<td>将Set中的元素增加一个权重参数score,元素按score有序排列</td>
<td>数据插入集合时,已经进行天然排序</td>
<td>1、排行榜 2、带权重的消息队列 3、去重还可以排序，比如获取排名前几名用户。4，是set的增强版本，增加了一个score参数，自动会根据score的值进行排序。比较适合类似于top 10等不根据插入的时间来排序的数据。</td>
</tr>
</tbody></table>
<h2 id="String-应用场景"><a href="#String-应用场景" class="headerlink" title="String 应用场景"></a>String 应用场景</h2><ul>
<li><strong>缓存功能：String</strong>字符串是最常用的数据类型，不仅仅是<strong>Redis</strong>，各个语言都是最基本类型，因此，利用<strong>Redis</strong>作为缓存，配合其它数据库作为存储层，利用<strong>Redis</strong>支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</li>
<li><strong>计数器：\</strong>许多系统都会使用*<em>Redis*</em>作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</li>
<li><strong>共享用户Session：\</strong>用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存*<em>Cookie*</em>，但是可以利用<strong>Redis</strong>将用户的<strong>Session</strong>集中管理，在这种模式只需要保证<strong>Redis</strong>的高可用，每次用户<strong>Session</strong>的更新和获取都可以快速完成。大大提高效率。</li>
</ul>
<h2 id="Hash-应用场景"><a href="#Hash-应用场景" class="headerlink" title="Hash 应用场景"></a>Hash 应用场景</h2><p>这个是类似 <strong>Map</strong> 的一种结构，这个一般就是可以将结构化的数据，比如一个对象（前提是<strong>这个对象没嵌套其他的对象</strong>）给缓存在 <strong>Redis</strong> 里，然后每次读写缓存的时候，可以就操作 <strong>Hash</strong> 里的<strong>某个字段</strong>。</p>
<p>但是这个的场景其实还是多少单一了一些，因为现在很多对象都是比较复杂的，比如你的商品对象可能里面就包含了很多属性，其中也有对象。我自己使用的场景用得不是那么多。</p>
<h2 id="List-应用场景"><a href="#List-应用场景" class="headerlink" title="List 应用场景"></a>List 应用场景</h2><p><strong>List</strong> 是有序列表，这个还是可以玩儿出很多花样的。</p>
<p>比如可以通过 <strong>List</strong> 存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的东西。</p>
<p>比如可以通过 <strong>lrange</strong> 命令，读取某个闭区间内的元素，可以基于 <strong>List</strong> 实现分页查询，这个是很棒的一个功能，基于 <strong>Redis</strong> 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西，性能高，就一页一页走。</p>
<p>比如可以搞个简单的消息队列，从 <strong>List</strong> 头怼进去，从 <strong>List</strong> 屁股那里弄出来。</p>
<p><strong>List</strong>本身就是我们在开发过程中比较常用的数据结构了，热点数据更不用说了。</p>
<ul>
<li><p><strong>消息队列：Redis</strong>的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过<strong>Lpush</strong>命令从左边插入数据，多个数据消费者，可以使用<strong>BRpop</strong>命令阻塞的“抢”列表尾部的数据。</p>
</li>
<li><p>文章列表或者数据分页展示的应用。</p>
<p>比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用<strong>Redis</strong>的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p>
</li>
</ul>
<h2 id="Set应用场景"><a href="#Set应用场景" class="headerlink" title="Set应用场景"></a>Set应用场景</h2><p><strong>Set</strong> 是无序集合，会自动去重的那种。</p>
<p>直接基于 <strong>Set</strong> 将系统里需要去重的数据扔进去，自动就给去重了，如果你需要对一些数据进行快速的全局去重，你当然也可以基于 <strong>JVM</strong> 内存里的 <strong>HashSet</strong> 进行去重，但是如果你的某个系统部署在多台机器上呢？得基于<strong>Redis</strong>进行全局的 <strong>Set</strong> 去重。</p>
<p>可以基于 <strong>Set</strong> 玩儿交集、并集、差集的操作，比如交集吧，我们可以把两个人的好友列表整一个交集，看看俩人的共同好友是谁。</p>
<p>还有一个比较典型的场景是标签（tag），例如一个用户可能对娱乐，体育比较感兴趣，另一个用户对历史，新闻比较感兴趣，这些兴趣点就是标签，有了这些数据就可以得到喜欢同一个标签的人，以及用户的共同喜欢标签</p>
<h2 id="Sorted-Set-应用场景"><a href="#Sorted-Set-应用场景" class="headerlink" title="Sorted Set 应用场景"></a>Sorted Set 应用场景</h2><p><strong>Sorted set</strong> 是排序的 <strong>Set</strong>，去重但可以排序，写进去的时候给一个分数，自动根据分数排序。</p>
<p>有序集合的使用场景与集合类似，但是set集合不是自动有序的，而<strong>Sorted set</strong>可以利用分数进行成员间的排序，而且是插入时就排序好。所以当你需要一个有序且不重复的集合列表时，就可以选择<strong>Sorted set</strong>数据结构作为选择方案。</p>
<ul>
<li><p>排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>
</li>
<li><p>用<strong>Sorted Sets</strong>来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
<p>微博热搜榜，就是有个后面的热度值，前面就是名称</p>
</li>
</ul>
<h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ol>
<li><p><code>计数器</code></p>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
</li>
<li><p><code>缓存</code></p>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
</li>
<li><p><code>会话缓存</code></p>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
</li>
<li><p><code>全页缓存</code></p>
<p>除基本的会话token之外，Redis还提供很简便的FPC平台。以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
</li>
<li><p><code>查找表</code></p>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
</li>
<li><p><code>消息队列(发布/订阅功能)</code></p>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
</li>
<li><p><code>分布式锁实现</code></p>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
</li>
<li><p>其他</p>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
</li>
</ol>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p> <strong>Bitmap</strong> :</p>
<p>位图是支持按 bit 位来存储信息，可以用来实现 <strong>布隆过滤器（BloomFilter）</strong>；</p>
<p> <strong>HyperLogLog:</strong></p>
<p>供不精确的去重计数功能，比较适合用来做大规模数据的去重统计，例如统计 UV；</p>
<p> <strong>Geospatial:</strong></p>
<p>可以用来保存地理位置，并作位置距离计算或者根据半径计算位置等。有没有想过用Redis来实现附近的人？或者计算最优地图路径？</p>
<p>这三个其实也可以算作一种数据结构，不知道还有多少朋友记得，我在梦开始的地方，Redis基础中提到过，你如果只知道五种基础类型那只能拿60分，如果你能讲出高级用法，那就觉得你<strong>有点东西</strong>。</p>
<p> <strong>pub/sub：</strong></p>
<p>功能是订阅发布功能，可以用作简单的消息队列。</p>
<p> <strong>Pipeline：</strong></p>
<p>可以批量执行一组指令，一次性返回全部结果，可以减少频繁的请求应答。</p>
<p> <strong>Lua：</strong></p>
<p><strong>Redis</strong> 支持提交 <strong>Lua</strong> 脚本来执行一系列的功能。</p>
<p>秒杀场景经常使用这个东西，讲道理有点香，利用他的原子性。</p>
<p> <strong>事务：</strong></p>
<p>最后一个功能是事务，但 <strong>Redis</strong> 提供的不是严格的事务，<strong>Redis</strong> 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去。</p>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。</p>
<p>持久化方式：</p>
<ul>
<li>快照：1. MySQL dump 2. redis RDB</li>
<li>写日志：1. MySQL binlog  2. Hbase Hlog  3. Redis AOF </li>
</ul>
<h2 id="RDB-–-内存快照（宕机快速恢复）"><a href="#RDB-–-内存快照（宕机快速恢复）" class="headerlink" title="RDB – 内存快照（宕机快速恢复）"></a>RDB – 内存快照（宕机快速恢复）</h2><p>RDB 是 Redis DataBase 的缩写，是Redis默认的持久化方式。按照一定的时间周期策略把内存的数据以快照的形式保存到硬盘的二进制文件。即Snapshot快照存储，对应产生的数据文件为<code>dump.rdb</code>，通过配置文件中的save参数来定义快照的周期。（ 快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品）</p>
<p>和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。</p>
<p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是全量快照，也就是说，把内存中的所有数据都记录到磁盘中。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p>
<blockquote>
<p>save：在主线程中执行，会导致阻塞.</p>
<p>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</p>
</blockquote>
<p>redis会单独创建（fork）一个与当前进程一模一样的子进程进行持久化，这个子进程的所有数据（变量，环境变量，程序设计器）都和原进程一模一样。会先将数据写入到一个临时文件中，待持久化结束后，再用这个临时文件替换上次持久化好的文件，整个过程中主进程不进行任何io操作，这保证极高的性能。</p>
<p>为什么要fork一个子进程：因为redis是单进程的，同一时刻只能做一件事，所以fork子进程去持久化</p>
<h3 id="快照时数据能修改吗"><a href="#快照时数据能修改吗" class="headerlink" title="快照时数据能修改吗?"></a>快照时数据能修改吗?</h3><p>Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p>
<p>简单来说，bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p>
<p>此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p><img src="/images/redis-24.jpg" alt="redis-1"></p>
<p>这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p>
<h3 id="增加快照"><a href="#增加快照" class="headerlink" title="增加快照"></a>增加快照</h3><p>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。</p>
<blockquote>
<p>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</p>
<p>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</p>
</blockquote>
<p>RDB采用增量快照，就是指，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。</p>
<p>在第一次做完全量快照后，T1 和 T2 时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。但是，这么做的前提是，我们需要记住哪些数据被修改了。它需要我们使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。如下图所示：</p>
<p><img src="/images/redis-25.jpg" alt="redis-1"></p>
<p>虽然跟 AOF 相比，快照的恢复速度快，但是，快照的频率不好把握，如果频率太低，两次快照间一旦宕机，就可能有比较多的数据丢失。如果频率太高，又会产生额外开销。</p>
<h3 id="什么时候fork子进程（触发RDB持久化机制）"><a href="#什么时候fork子进程（触发RDB持久化机制）" class="headerlink" title="什么时候fork子进程（触发RDB持久化机制）"></a>什么时候fork子进程（触发RDB持久化机制）</h3><ol>
<li><p>shutdown时，如果没有开启aof会触发</p>
</li>
<li><p>配置文件中</p>
</li>
</ol>
<p>指定多长时间内，多少次更新操作，就将数据同步到数据文件，可以多个条件配合。</p>
<p>下面表示900秒（15分钟内）有一个更改，300秒内有10个更改以及60秒内有10000个更改就会触发</p>
<p><img src="/images/redis-13.png" alt="redis-1"></p>
<ol start="3">
<li>执行命令save或者bgsave</li>
</ol>
<p><code>save</code>命令只管保存，其他不管，全部阻塞，save是使用主进程去持久化，此时是不能够操作redis的，它是一个同步操作。</p>
<p><code>bgsave</code>命令redis会在后台异步进行持久化，过程是会fork一个子进程，这个进程再创建RDB文件</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是（阻塞发生在fork，redis内存越大耗时越长）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork消耗内存</td>
</tr>
</tbody></table>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>他会生成多个数据文件，每个数据文件分别都代表了某一时刻<strong>Redis</strong>里面的数据，这种方式，有没有觉得很适合做<strong>冷备</strong>，完整的数据运维设置定时任务，定时同步到远端的服务器，比如阿里的云服务，这样一旦线上挂了，你想恢复多少分钟之前的数据，就去远端拷贝一份之前的数据就好了。</p>
<p><strong>RDB</strong>对<strong>Redis</strong>的性能影响非常小，是因为在同步数据的时候他只是<strong>fork</strong>了一个子进程去做持久化的，而且他在数据恢复的时候速度比<strong>AOF</strong>来的快。</p>
<p><strong>RDB</strong>都是快照文件，都是默认五分钟甚至更久的时间才会生成一次，这意味着你这次同步到下次同步这中间五分钟的数据都很可能全部丢失掉。<strong>AOF</strong>则最多丢一秒的数据，<strong>数据完整性</strong>上高下立判。</p>
<p>还有就是<strong>RDB</strong>在生成数据快照的时候，如果文件很大，客户端可能会暂停几毫秒甚至几秒，你公司在做秒杀的时候他刚好在这个时候<strong>fork</strong>了一个子进程去生成一个大快照，那就出大问题了。</p>
<h2 id="AOF-—-避免数据丢失"><a href="#AOF-—-避免数据丢失" class="headerlink" title="AOF — 避免数据丢失"></a>AOF — 避免数据丢失</h2><p>说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），也就是说，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF 日志正好相反，它是写后日志，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。</p>
<p>那 AOF 为什么要先执行命令再记日志呢？要回答这个问题，我们要先知道 AOF 里记录了什么内容。传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p>
<p>我们以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“$+数字”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。</p>
<p><img src="/images/redis-20.jpg" alt="redis-6"></p>
<p>但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以避免出现记录错误命令的情况。</p>
<p>除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以不会阻塞当前的写操作</p>
<p><strong>AOF</strong> 机制对每条写入命令作为日志，以 <strong>append-only</strong> 的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像Mysql中的<strong>binlog</strong>。</p>
<p>Redis会将每一个收到的写<code>命令</code>都通过Write函数追加到文件最后，类似于MySQL的binlog。当Redis重启是会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。对应产生的数据库文件为<code>appendonly.aof</code></p>
<p>上面redis配置文件里触发持久化最少也要60秒，但是如果小于60秒退出数据就会丢失。AOF就是为了解决这个问题。AOF是不会超过两秒，每秒钟保存一次数据。</p>
<p>AOF保存的是<code>命令</code>字符串，还有协议。</p>
<h3 id="AOF三种写回策略"><a href="#AOF三种写回策略" class="headerlink" title="AOF三种写回策略"></a>AOF三种写回策略</h3><p>首先，如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p>
<p>其次，AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</p>
<p>仔细分析的话，就会发现，这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p>
<p>其实，对于这个问题，AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。</p>
<blockquote>
<p>Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</p>
<p>Everysec，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</p>
<p>No，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</p>
</blockquote>
<p>同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能。</p>
<p>虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了。</p>
<p>“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</p>
<p><img src="/images/redis-21.jpg" alt="redis-6"></p>
<h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>当aof增长到一定大小的时候Redis能够调用bgrewriteaof对日志文件进行重写。</p>
<p>例如：如果新建了数据，然后又删除了，这时这两条命令就不需要保存了，或者set同一个key多次，那我们只需要保存最后一次的命令即可</p>
<p><img src="/images/redis-22.jpg" alt="redis-6"></p>
<p>AOF重写机制的目的是：减少磁盘占用量，加速恢复速度</p>
<p>AOF重写的两种方式：</p>
<ul>
<li>bgrewriteaof命令。同样redis会fork一个子进程进行重写，<code>注意：fork是同步操作会阻塞redis</code></li>
<li>AOF重写配置，见下图</li>
</ul>
<p><img src="/images/redis-6.png" alt="redis-6"></p>
<p>auto-aof-rewrite-min-size：AOF文件重写需要的尺寸</p>
<p>auto-aof-rewrite-percentage：AOF文件增长率</p>
<p>次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此<br>时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p>
<p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，对于正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p>
<p>对于新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这<br>样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</p>
<p><img src="/images/redis-23.jpg" alt="redis-6"></p>
<p>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</p>
<h3 id="AOF-重写过程中有没有其他潜在的阻塞风险？"><a href="#AOF-重写过程中有没有其他潜在的阻塞风险？" class="headerlink" title="AOF 重写过程中有没有其他潜在的阻塞风险？"></a>AOF 重写过程中有没有其他潜在的阻塞风险？</h3><p>风险一：Redis 主线程 fork 创建 bgrewriteaof 子进程时，内核需要创建用于管理子进程的相关数据结构，这些数据结构在操作系统中通常叫作进程控制块（Process Control<br>Block，简称为 PCB）。内核要把主线程的 PCB 内容拷贝给子进程。这个创建和拷贝过程由内核执行，是会阻塞主线程的。而且，在拷贝过程中，子进程要拷贝父进程的页表，这个过程的耗时和 Redis 实例的内存大小有关。如果 Redis 实例内存大，页表就会大，fork 执行时间就会长，这就会给主线程带来阻塞风险。</p>
<p>风险二：bgrewriteaof 子进程会和主线程共享内存。当主线程收到新写或修改的操作时，主线程会申请新的内存空间，用来保存新写或修改的数据，如果操作的是 bigkey，也就是数据量大的集合类型数据，那么，主线程会因为申请大空间而面临阻塞风险。因为操作系统在分配内存空间时，有查找和锁的开销，这就会导致阻塞。</p>
<h3 id="AOF追加阻塞"><a href="#AOF追加阻塞" class="headerlink" title="AOF追加阻塞"></a>AOF追加阻塞</h3><p><img src="/images/redis-14.png" alt="redis-14"></p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>上面提到了，<strong>RDB</strong>五分钟一次生成快照，但是<strong>AOF</strong>是一秒一次去通过一个后台的线程<code>fsync</code>操作，那最多丢这一秒的数据。</p>
<p><strong>AOF</strong>在对日志文件进行操作的时候是以<code>append-only</code>的方式去写的，他只是追加的方式写数据，自然就少了很多磁盘寻址的开销了，写入性能惊人，文件也不容易破损。</p>
<p><strong>AOF</strong>的日志是通过一个叫<strong>非常可读</strong>的方式记录的，这样的特性就适合做<strong>灾难性数据误删除</strong>的紧急恢复了，比如公司的实习生通过<strong>flushall</strong>清空了所有的数据，只要这个时候后台重写还没发生，你马上拷贝一份<strong>AOF</strong>日志文件，把最后一条<strong>flushall</strong>命令删了就完事了。</p>
<p>RDB性能消耗低，丢失数据多，速度也快。AOF性能消耗高，丢失数据少</p>
<p>一样的数据，<strong>AOF</strong>文件比<strong>RDB</strong>还要大。</p>
<p><strong>AOF</strong>开启后，<strong>Redis</strong>支持写的<strong>QPS</strong>会比<strong>RDB</strong>支持写的要低，他不是每秒都要去异步刷新一次日志嘛<strong>fsync</strong>，当然即使这样性能还是很高，我记得<strong>ElasticSearch</strong>也是这样的，异步刷新缓存区的数据去持久化，为啥这么做呢，不直接来一条怼一条呢，因为这样性能可能低到没办法用的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>redis提供了RDB持久化方案，为什么还要aof</strong></p>
<p>优化数据丢失问题，rdb会丢失最后一次快照后的数据，aof丢失不会超过两秒的数据</p>
<p><strong>如果AOF和RDB同时存在，听谁的</strong></p>
<p>AOF，两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。</p>
<p><strong>RDB 和 AOF优劣势</strong></p>
<p>AOF性能消耗高，丢失数据少，RDB性能消耗低，丢失数据多，速度也快，RDB会对数据进行压缩</p>
<p><strong>RDB</strong>对<strong>Redis</strong>的性能影响非常小，是因为在同步数据的时候他只是<strong>fork</strong>了一个子进程去做持久化的，而且他在数据恢复的时候速度比<strong>AOF</strong>来的快。</p>
<p>两种方式都可以把<strong>Redis</strong>内存中的数据持久化到磁盘上，然后再将这些数据备份到别的地方去，<strong>RDB</strong>更适合做<strong>冷备</strong>，<strong>AOF</strong>更适合做<strong>热备</strong>，比如我杭州的某电商公司有这两个数据，我备份一份到我杭州的节点，再备份一个到上海的，就算发生无法避免的自然灾害，也不会两个地方都一起挂吧，这<strong>灾备</strong>也就是<strong>异地容灾</strong>。</p>
<h3 id="两者如何选择"><a href="#两者如何选择" class="headerlink" title="两者如何选择"></a>两者如何选择</h3><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p>
<p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<p>如下图所示，T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</p>
<p><img src="/images/redis-26.jpg" alt="redis-14"></p>
<p>这个方法既能享受到 RDB 文件快速恢复的好处，又能享受到 AOF 只记录操作命令的简单优势，颇有点“鱼和熊掌可以兼得”的感觉，建议在实践中用起来!</p>
<p>单独用<strong>RDB</strong>你会丢失很多数据，单独用<strong>AOF</strong>，你数据恢复没<strong>RDB</strong>来的快，真出什么时候第一时间用<strong>RDB</strong>恢复，然后<strong>AOF</strong>做数据补全，冷备热备一起上，才是互联网时代一个高健壮性系统的王道。</p>
<p>注意：bgsave和bgrewriteaof会fork子进程，这是阻塞的操作，redis内存越大耗时越长</p>
<h2 id="Redis过期键删除策略"><a href="#Redis过期键删除策略" class="headerlink" title="Redis过期键删除策略"></a>Redis过期键删除策略</h2><p><strong>Redis</strong>的过期策略，是有<strong>定期删除+惰性删除</strong>两种。</p>
<p>定期好理解，默认100ms就随机抽一些设置了过期时间的key，去检查是否过期，过期了就删了。</p>
<p>惰性删除，我不主动删，我等你来<strong>查询</strong>了我看看你过期没，过期就删了还不给你返回，没过期该怎么样就怎么样。</p>
<h2 id="Redis-内存淘汰策略"><a href="#Redis-内存淘汰策略" class="headerlink" title="Redis 内存淘汰策略"></a>Redis 内存淘汰策略</h2><p><a href="http://polygonx.top/wxning-blog/interview/redis/notes/02/02.html" target="_blank" rel="noopener">http://polygonx.top/wxning-blog/interview/redis/notes/02/02.html</a></p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>使用不存在的key（在数据库没有，自然在缓存中也不会有）进行大量的高并发查询，导致缓存无法命中，每次请求都要穿透到后端数据库进行查询，数据库压力过大</p>
<p>解决方案：</p>
<ul>
<li>将空值缓存起来</li>
<li>布隆过滤器</li>
</ul>
<p>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟(设置过期时间就是防止我们真的在数据库中存储了这个值就会导致一致性问题)。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。但是这个用个问题，如果是黑客攻击，可能会采用uuid去获取，这样会导致无法解决穿透到数据库获取数据的问题，所以我们一般使用布隆过滤器解决。</p>
<p><strong>布隆过滤器</strong>：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。通过一定的错误率换取空间（因为布隆过滤器里面数据避免太多，节约内存占用），降低错误率的方法有两种，增大数组，增加hash函数的个数</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库中取数据，引发数据库压力过大</p>
<p>一般来说不用处理，公司业务中也很少有那种并发量，即使有，只要数据库没有崩，我们就不用处理。</p>
<p>解决方案：</p>
<ul>
<li>互斥锁，如果项目不会多部署使用jvm锁，如果项目多部署则使用分布式锁（加锁之后第一个请求就会被锁住，然后就会把这个数据加入缓存，这样后面的请求就会在缓存中拿到了，不必请求数据库了）</li>
<li>二级缓存，再加一个redis缓存和当前缓存一模一样，相当于主从复制。</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存服务器重启或大量缓存集中在某一时间内失效</p>
<p>所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力</p>
<p>解决方案：</p>
<ul>
<li>搭建高可用集群，保证机器高可用</li>
<li>对不同的数据使用不同的实效时间，甚至对相同的数据不同的请求也使用不同的失效时间</li>
<li>大多数系统设计者考虑用加锁（ 最多的解决方案）或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>就是引入了k(k&gt;1)k(k&gt;1)个相互独立的哈希函数，保证在给定的空间、误判率下，完成元素判重的过程。</p>
<p>它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>
<p>Bloom-Filter算法的核心思想就是利用多个不同的Hash函数来解决“冲突”。</p>
<p>Hash存在一个冲突（碰撞）的问题，用同一个Hash得到的两个URL的值有可能相同。为了减少冲突，我们可以多引入几个Hash，如果通过其中的一个Hash值我们得出某元素不在集合中，那么该元素肯定不在集合中。只有在所有的Hash函数告诉我们该元素在集合中时，才能确定该元素存在于集合中。这便是Bloom-Filter的基本思想。</p>
<p>Bloom-Filter一般用于在大数据量的集合中判定某元素是否存在。</p>
<h2 id="缓存与数据库数据一致性"><a href="#缓存与数据库数据一致性" class="headerlink" title="缓存与数据库数据一致性"></a>缓存与数据库数据一致性</h2><h3 id="1-先更新缓存，再更新DB"><a href="#1-先更新缓存，再更新DB" class="headerlink" title="1.先更新缓存，再更新DB"></a>1.先更新缓存，再更新DB</h3><p>这个方案一般不考虑，原因是更新缓存成功，更新数据库出现异常了，导致缓存数据与数据库数据不一致，而且很难察觉</p>
<p><img src="/images/redis-73.png" alt="redis-14"></p>
<h3 id="2-先更新DB，再更新缓存"><a href="#2-先更新DB，再更新缓存" class="headerlink" title="2.先更新DB，再更新缓存"></a>2.先更新DB，再更新缓存</h3><p>这个方案我们也不考虑，原因和上面一样，数据库更新成功了，缓存更新失败，同样会出现数据不一致问题</p>
<p><img src="/images/redis-74.png" alt="redis-14"></p>
<p>而且这种方案还会有并发问题，同时有请求A和请求B进行更新操作，会出现：</p>
<ol>
<li>线程A更新了数据库</li>
<li>线程B更新了数据库</li>
<li>线程B更新了缓存</li>
<li>线程A更新了缓存</li>
</ol>
<p><img src="/images/redis-75.png" alt="redis-14"></p>
<p>这就出现了请求A更新缓存应该比请求B更新缓存早才对，但是因为网络问题B缺比A更新了缓存，这就导致了脏数据。</p>
<h3 id="3-先删除缓存，再更新DB"><a href="#3-先删除缓存，再更新DB" class="headerlink" title="3. 先删除缓存，再更新DB"></a>3. 先删除缓存，再更新DB</h3><p>该方案也有问题，比如：</p>
<p>两个请求，请求A更新操作，请求B查询操作，请求A会先删除缓存，再去更新DB，此时请求B看到redis中的数据是空的，会去数据库中查询该值并补录到redis中，但是此时请求A并没有更新成功或者事务还未提交，请求B去数据库中查询的是旧值。</p>
<p><img src="/images/redis-76.png" alt="redis-14"></p>
<p>如何解决呢？，最简单的办法就是<code>延时双删</code>：</p>
<ul>
<li>先淘汰缓存</li>
<li>再写数据库</li>
<li>休眠一段时间再次淘汰缓存</li>
</ul>
<p>这样确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<h3 id="4-先更新DB，再删除缓存"><a href="#4-先更新DB，再删除缓存" class="headerlink" title="4.先更新DB，再删除缓存"></a>4.先更新DB，再删除缓存</h3><p>这种方式被称为 Cache Aside Pattern，读的时候先读缓存，缓存没有再读数据库，然后取出数据后放入缓存。更新的时候先更新数据库，然后再删除缓存。</p>
<p>这种情况依然会有并发问题，假设请求A做查询操作，请求B做更新操作：</p>
<ul>
<li>缓存刚好失效</li>
<li>请求A查询数据库，得到一个旧值</li>
<li>请求B将新值写入数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值写入缓存</li>
</ul>
<p><img src="/images/redis-77.png" alt="redis-14"></p>
<p>然而，发生这种情况的概率很低，原因就是步骤3的写数据操作比步骤2的读数据操作耗时更短才有机会发生，但是，数据库的读操作速度远快于写操作。</p>
<p>如果真的发生了，该怎么解决呢？</p>
<p>首先，给缓存设置有效过期时间是一种方案</p>
<p>其次，采用异步延时删除策略</p>
<p>可以参考：<a href="http://polygonx.top/wxning-blog/interview/redis/notes/02/03.html" target="_blank" rel="noopener">http://polygonx.top/wxning-blog/interview/redis/notes/02/03.html</a></p>
<h2 id="单线程的redis为什么这么快"><a href="#单线程的redis为什么这么快" class="headerlink" title="单线程的redis为什么这么快"></a>单线程的redis为什么这么快</h2><p><strong>Redis</strong>采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的<strong>QPS（每秒内查询次数）</strong></p>
<ol>
<li>存内存操作：完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。它的数据存在内存中，类似于<strong>HashMap</strong>，<strong>HashMap</strong>的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>数据结构简单，对数据操作也简单，<strong>Redis</strong>中的数据结构是专门进行设计的</li>
<li>单线程操作：采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 <strong>CPU</strong>，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>使用多路I/O复用模型，非阻塞IO；</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，<strong>Redis</strong>直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<p>上下文切换：比如你看一本英文书，你看到第十页发现有个单词不会读，你加了个书签，然后去查字典，过了一会你又回来继续从书签那里读，ok到目前为止没啥问题。</p>
<p>如果是你一个人读肯定没啥问题，但是你去查的时候，别的小伙伴好奇你在看啥他就翻了一下你的书，然后溜了，哦豁，你再看的时候就发现书不是你看的那一页了。为啥会线程不安全，就是因为你一个人怎么看都没事，但是人多了换来换去的操作一本书数据就乱了。道理是一样的。</p>
<h2 id="Redis变慢的场景"><a href="#Redis变慢的场景" class="headerlink" title="Redis变慢的场景"></a>Redis变慢的场景</h2><ol>
<li>使用复杂度过高的命令或一次查询全量数据；</li>
<li>操作 bigkey；</li>
<li>大量 key 集中过期；3.</li>
<li>内存达到 maxmemory；</li>
<li>客户端使用短连接和 Redis 相连；</li>
<li>当 Redis 实例的数据量大时，无论是生成 RDB，还是 AOF 重写，都会导致 fork 耗时严重；</li>
<li>AOF 的写回策略为 always，导致每个操作都要同步刷回磁盘；</li>
<li>Redis 实例运行机器的内存不足，导致 swap 发生，Redis 需要到 swap 分区读取数据；</li>
<li>进程绑定 CPU 不合理；</li>
<li>Redis 实例运行机器上开启了透明内存大页机制；</li>
<li>网卡压力过大。</li>
</ol>
<h2 id="Redis架构模式"><a href="#Redis架构模式" class="headerlink" title="Redis架构模式"></a>Redis架构模式</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p><img src="/images/redis-27.jpg" alt="redis-3"></p>
<p><strong>主从库间网络断了怎么办？</strong></p>
<p><img src="/images/redis-31.jpg" alt="redis-31"></p>
<p>在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。从 Redis 2.8 开始，网络断了之后，主从库会采用增量复制的方式继续同步。听名字大概<br>就可以猜到它和全量复制的不同：全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。</p>
<p>当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。</p>
<p>repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。</p>
<p>刚开始的时候，主库和从库的写读位置在一起，这算是它们的起始位置。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，我们通常用偏移量来衡量这个偏移距离的大小，对主库来说，对应的偏移量就是 master_repl_offset。主库接收的新写操作越多，这个值就会越大。</p>
<p>同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。</p>
<p><img src="/images/redis-30.jpg" alt="redis-3"></p>
<p>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的 slave_repl_offset 发给主库，主库会判断自己的master_repl_offset 和 slave_repl_offset 之间的差距。</p>
<p>在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset 之间的命令操作同步给从库就行。</p>
<p>不过，有一个地方我要强调一下，因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。</p>
<p>因此，我们要想办法避免这一情况，一般而言，我们可以调整repl_backlog_size 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 repl_backlog_size = 缓冲空间大小 * 2，这也就是repl_backlog_size 的最终值。</p>
<p><strong>主从复制优缺点</strong></p>
<p>特点：</p>
<ul>
<li>master/slave 角色</li>
<li>master/slave 数据相同</li>
<li>降低 master 读压力，再转交从库</li>
<li>读写分离，容灾备份</li>
<li>主专门写数据，从专门读数据</li>
</ul>
<hr>
<p>缺点：</p>
<ul>
<li>无法保证高可用</li>
<li>没有解决 master 写的压力</li>
<li>主机挂了不能自动切换从机，需要手动切换（哨兵解决）</li>
</ul>
<p><strong>主从之间数据的同步</strong></p>
<p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p>
<p><img src="/images/redis-28.jpg" alt="image-20210124195123383"></p>
<p>第一阶段是主从库间建立连接、协商同步的过程，主要是为全量复制做准备。在这一步，从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>
<p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。</p>
<blockquote>
<p>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的runID，所以将 runID 设为“？”。</p>
<p>offset，此时设为 -1，表示第一次复制。</p>
</blockquote>
<p>主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库</p>
<p>目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。</p>
<p>这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p>
<p>在第二阶段，主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>
<p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>
<p>最后，也就是第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<hr>
<p><strong>主从级联模式分担全量复制时的主库压力</strong></p>
<p>一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。以通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上。<br><img src="/images/redis-29.jpg" alt="redis-29"></p>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>在主从模式下，如果从库发生故障了，客户端可以继续向主库或其他从库发送请求，进行相关的操作，但是如果主库发生故障了，那就直接会影响到从库的同步，因为从库没有相应的主库可以进行数据复制操作了。</p>
<p>而且，如果客户端发送的都是读操作请求，那还可以由从库继续提供服务，这在纯读的业务场景下还能被接受。但是，一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作。此时，也没有实例可以来服务客户端的写操作请求了。</p>
<p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<p>监控是指哨兵进程在运行时，周期性地给所有的主从库发送PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；同样，如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始自动切换主库的流程。</p>
<p>这个流程首先是执行哨兵的第二个任务，选主。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。这一步完成后，现在的集群里就有了新主库。</p>
<p>然后，哨兵会执行最后一个任务：通知。在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</p>
<p><img src="/images/redis-32.jpg" alt="redis-4"></p>
<p>首先，我们要知道啥叫误判。很简单，就是主库实际并没有下线，但是哨兵误以为它下线了。误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。</p>
<p>一旦哨兵判断主库下线了，就会开始选择新主库，并让从库和新主库进行数据同步，这个过程本身就会有开销，例如，哨兵要花时间选出新主库，从库也需要花时间和新主库同步。而在误判的情况下，主库本身根本就不需要进行切换的，所以这个过程的开销是没有价值的。正因为这样，我们需要判断是否有误判，以及减少误判。</p>
<p>哨兵机制通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判的概率，也能避免误判带来的无谓的主从库切换。</p>
<p><strong>如何选定新主库？</strong><br>一般来说，我把哨兵选择新主库的过程称为“筛选 + 打分”。简单来说，我们在多个从库中，先按照一定的筛选条件，把不符合条件的从库去掉。然后，我们再按照一定的规则，给剩下的从库逐个打分，将得分最高的从库选为新主库，如下图所示：</p>
<p><img src="/images/redis-33.jpg" alt="redis-33"></p>
<p>首先来看筛选的条件。<br>一般情况下，我们肯定要先保证所选的从库仍然在线运行。不过，在选主时从库正常在线，这只能表示从库的现状良好，并不代表它就是最适合做主库的。</p>
<p>设想一下，如果在选主时，一个从库正常运行，我们把它选为新主库开始使用了。可是，很快它的网络出了故障，此时，我们就得重新选主了。这显然不是我们期望的结果。</p>
<p>所以，在选主时，除了要检查从库的当前在线状态，还要判断它之前的网络连接状态。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</p>
<p>具体怎么判断呢？你使用配置项 down-after-milliseconds * 10。其中，down-after-milliseconds 是我们认定主从库断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p>
<p>好了，这样我们就过滤掉了不适合做主库的从库，完成了筛选工作。</p>
<p>接下来就要给剩余的从库打分了。我们可以分别按照三个规则依次进行三轮打分，这三个规则分别是从库优先级、从库复制进度以及从库 ID 号。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p>
<p>第一轮：优先级最高的从库得分高。</p>
<p>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p>
<p>第二轮：和旧主库同步程度最接近的从库得分高。</p>
<p>这个规则的依据是，如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。</p>
<p>如何判断从库和旧主库间的同步进度呢？</p>
<p>主从库同步时有个命令传播的过程。在这个过程中，主库会用<br>master_repl_offset 记录当前的最新写操作在repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。</p>
<p>此时，我们想要找的从库，它的 slave_repl_offset 需要最接近 master_repl_offset。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。</p>
<p>就像下图所示，旧主库的 master_repl_offset 是 1000，从库 1、2 和 3 的 slave_repl_offset 分别是 950、990 和 900，那么，从库 2 就应该被选为新主库。</p>
<p><img src="/images/redis-34.jpg" alt="redis-4"></p>
<p>当然，如果有两个从库的 slave_repl_offset 值大小是一样的（例如，从库 1 和从库 2 的 slave_repl_offset 值都是 990），我们就需要给它们进行第三轮打分了。</p>
<p>第三轮：ID 号小的从库得分高。</p>
<p>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库。</p>
<p>到这里，新主库就被选出来了，“选主”这个过程就完成了。</p>
<p>我们再回顾下这个流程。首先，哨兵会按照在线状态、网络状态，筛选过滤掉一部分不符合要求的从库，然后，依次按照优先级、复制进度、ID 号大小再对剩余的从库进行打分，只要有得分最高的从库出现，就把它选为新主库。</p>
<p><img src="/images/redis-4.png" alt="redis-4"></p>
<p>Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：</p>
<ul>
<li>监控（Monitoring）：  Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</li>
<li>提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</li>
<li>自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。</li>
</ul>
<p><strong>特点：</strong></p>
<p>优点</p>
<ul>
<li>保证高可用</li>
<li>监控各个节点</li>
<li>自动故障迁移</li>
</ul>
<p>缺点：</p>
<ul>
<li>主从模式，切换需要时间，丢数据</li>
<li>没有解决 master 写的压力</li>
</ul>
<h3 id="Redis-Cluster高可用集群"><a href="#Redis-Cluster高可用集群" class="headerlink" title="Redis Cluster高可用集群"></a>Redis Cluster高可用集群</h3><p><strong>解决单机的瓶颈</strong></p>
<p>用集群的部署方式也就是<strong>Redis cluster</strong>，并且是主从同步读写分离，类似<strong>Mysql</strong>的主从同步，<strong>Redis cluster</strong> 支撑 N 个 <strong>Redis master node</strong>，每个<strong>master node</strong>都可以挂载多个 <strong>slave node</strong>。</p>
<p>这样整个 <strong>Redis</strong> 就可以横向扩容了。如果你要支撑更大数据量的缓存，那就横向扩容更多的 <strong>master</strong> 节点，每个 <strong>master</strong> 节点就能存放更多的数据了。</p>
<p>哨兵模式下故障转移过程中整个redis服务是不可用的</p>
<p>redis cluster是由多个主从节点群组成的分布式集群</p>
<p><img src="/images/redis-5.png" alt="redis-5"></p>
<p>Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。</p>
<p><img src="/images/redis-7.png" alt="redis-7"></p>
<p>对命令的key进行crc16（hash一致性算法）算法得到一串数字，再对16384取余，结果在哪个区间（槽位）就分配给哪个集群</p>
<p>即使其中一个小集群挂了，仍然有三分之二的几率是可用的，等故障转移之后可用性全部恢复了，当然实际生产中还是要看集群的数量</p>
<p><strong>数据分片原理</strong></p>
<p>一个需求：要用 Redis 保存 5000 万个键值对，每个键值对大约是 512B，为了能快速部署并对外提供服务，我们采用云主机来运行 Redis 实例，那么，该如何选择云主机的内存容量呢？</p>
<p>我粗略地计算了一下，这些键值对所占的内存空间大约是 25GB（5000 万 *512B）。所以，当时，我想到的第一方案就是：选择一台 32GB 内存的云主机来部署 Redis。因为 32GB 的内存能保存所有数据，而且还留有 7GB，可以保证系统的正常运行。同时，我还采用 RDB 对数据做持久化，以确保 Redis 实例故障后，还能从 RDB 恢复数据。</p>
<p>但是，在使用的过程中，我发现，Redis 的响应有时会非常慢。后来，我们使用 INFO 命令查看 Redis 的latest_fork_usec 指标值（表示最近一次 fork 的耗时），结果显示这个指标值特别高，快到秒级别了。</p>
<p>这跟 Redis 的持久化机制有关系。在使用 RDB 进行持久化时，Redis 会 fork 子进程来完成，fork 操作的用时和 Redis 的数据量是正相关的，而 fork 在执行时会阻塞主线程。数据量越大，fork 操作造成的主线程阻塞的时间越长。所以，在使用 RDB 对 25GB 的数据进行持久化时，数据量较大，后台运行的子进程在 fork 创建时阻塞了主线程，于是就导致<br>Redis 响应变慢了。</p>
<p>看来，第一个方案显然是不可行的，我们必须要寻找其他的方案。这个时候，我们注意到了 Redis 的切片集群。虽然组建切片集群比较麻烦，但是它可以保存大量数据，而且对 Redis 主线程的阻塞影响较小。</p>
<p>切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。回到我们刚刚的场景中，如果把 25GB 的数据平均分成 5 份（当然，也可以不做均分），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。如下图所示：</p>
<p><img src="/images/redis-35.jpg" alt="redis-3"></p>
<p>那么，在切片集群中，实例在为 5GB 数据生成 RDB 时，数据量就小了很多，fork 子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，我们既能保存25GB 数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢。</p>
<p>在实际应用 Redis 时，随着用户或业务规模的扩展，保存大量数据的情况通常是无法避免的。而切片集群，就是一个非常好的解决方案。</p>
<p><strong>数据切片和实例的对应分布关系</strong></p>
<p>在切片集群中，数据需要分布在不同实例上，那么，数据和实例之间如何对应呢？这就和接下来我要讲的 Redis Cluster 方案有关了。不过，我们要先弄明白切片集群和 Redis Cluster 的联系与区别。</p>
<p>实际上，切片集群是一种保存大量数据的通用机制，这个机制可以有不同的实现方案。在 Redis 3.0 之前，官方并没有针对切片集群提供具体的方案。从 3.0 开始，官方提供了一个名为 Redis Cluster 的方案，用于实现切片集群。Redis Cluster 方案中就规定了数据和实例的对应规则。</p>
<p>具体来说，Redis Cluster 方案采用哈希槽（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384<br>个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</p>
<p>具体的映射过程分为两大步：首先根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值；然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</p>
<p>那么，这些哈希槽又是如何被映射到具体的 Redis 实例上的呢？</p>
<p>我们在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。</p>
<p><img src="/images/redis-36.jpg" alt="redis-3"></p>
<p>示意图中的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，我们首先可以通过下面的命令手动分配哈希槽：实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存<br>哈希槽 4。</p>
<p><strong>客户端如何定位数据？</strong></p>
<p>在定位键值对数据时，它所处的哈希槽是可以通过计算得到的，这个计算可以在客户端发送请求时来执行。但是，要进一步定位到实例，还需要知道哈希槽分布在哪个实例上。</p>
<p>一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。</p>
<p>那么，客户端为什么可以在访问任何一个实例时，都能获得所有的哈希槽信息呢？这是因为，Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p>
<p>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p>
<blockquote>
<p>在集群中，实例有新增或删除，Redis 需要重新分配哈希<br>槽；</p>
<p>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布&gt; 一遍。</p>
</blockquote>
<p>此时，实例之间还可以通过相互传递消息，获得最新的哈希槽分配信息，但是，客户端是无法主动感知这些变化的。这就会导致，它缓存的分配信息和最新的分配信息就不一致了，那该怎么办呢？</p>
<p>Redis Cluster 方案提供了一种重定向机制，所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。</p>
<p>那客户端又是怎么知道重定向时的新实例的访问地址呢？当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:key</span><br><span class="line">(error) MOVED 13320 172.16.19.5:6379</span><br></pre></td></tr></table></figure>

<p>其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在 172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。</p>
<p><strong>特点：</strong></p>
<ul>
<li>无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本</li>
<li>实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>资源隔离性较差，容易出现相互影响的情况。</li>
<li>数据通过异步复制,不保证数据的强一致性</li>
</ul>
<h2 id="Redis-相比-Memcached-有哪些优势？"><a href="#Redis-相比-Memcached-有哪些优势？" class="headerlink" title="Redis 相比 Memcached 有哪些优势？"></a>Redis 相比 Memcached 有哪些优势？</h2><ul>
<li><p>Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类</p>
</li>
<li><p>Redis 的速度比Memcached快很</p>
</li>
<li><p>Redis 可以持久化其数据</p>
</li>
</ul>
<p>Memcache 与 Redis 的区别都有哪些？</p>
<ul>
<li><p>存储方式Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部份存在硬盘上，这样能保证数据的持久性。</p>
</li>
<li><p>数据支持类型Memcache 对数据类型支持相对简单。Redis 有复杂的数据类型。</p>
</li>
<li><p>使用底层模型不同它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
</li>
</ul>
<h2 id="为什么用redis而不用map等本地缓存做缓存？"><a href="#为什么用redis而不用map等本地缓存做缓存？" class="headerlink" title="为什么用redis而不用map等本地缓存做缓存？"></a>为什么用redis而不用map等本地缓存做缓存？</h2><p>本地缓存最主要的特点是轻量而且快速，但是在多实例情况下每个实例都需要各自保存一份缓存，缓存不具有一致性。使用redis做分布式缓存，在多实例情况下，各实例共用同一份缓存数据，缓存具有一致性，缺点是需要保存redis的高可用，程序架构上需要引入其他组件</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="http://www.redis.cn/" target="_blank" rel="noopener">Redis中文网</a></p>
</li>
<li><p><a href="https://github.com/doocs/technical-books#database" target="_blank" rel="noopener">Redis设计与实现</a>——黄健宏</p>
</li>
<li><p>Redis 核心技术与实战</p>
</li>
</ul>

      
    </div>
    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      
    </div>

    <div>
          
            
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2020/03/28/redis/">redis知识汇总</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Wxning 的个人博客">Wxning</a></p>
  <p><span>发布时间:</span>2020年03月28日 - 23:03</p>
  <p><span>最后更新:</span>2022年02月26日 - 16:02</p>
  <p><span>原始链接:</span><a href="/2020/03/28/redis/" title="redis知识汇总">http://yoursite.com/2020/03/28/redis/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://yoursite.com/2020/03/28/redis/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>
</div>
<script>
    var clipboard = new Clipboard('.fa-clipboard');
    $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({
          title: "",
          text: '复制成功',
          icon: "success",
          showConfirmButton: true
          });
    });
    });
</script>


          
    </div>

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/22/context/" rel="next" title="go语言context">
                <i class="fa fa-chevron-left"></i> go语言context
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/02/pipeline/" rel="prev" title="go语言搭建pipeline">
                go语言搭建pipeline <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NTE2Ny8yMTY4NA=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Wxning">
            
              <p class="site-author-name" itemprop="name">Wxning</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/wxning1107" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis单线程优势"><span class="nav-number">1.</span> <span class="nav-text">Redis单线程优势</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么不用多线程？"><span class="nav-number">1.1.</span> <span class="nav-text">为什么不用多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程-Redis-为什么那么快？"><span class="nav-number">1.2.</span> <span class="nav-text">单线程 Redis 为什么那么快？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis数据类型"><span class="nav-number">2.</span> <span class="nav-text">redis数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-应用场景"><span class="nav-number">3.</span> <span class="nav-text">String 应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-应用场景"><span class="nav-number">4.</span> <span class="nav-text">Hash 应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List-应用场景"><span class="nav-number">5.</span> <span class="nav-text">List 应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set应用场景"><span class="nav-number">6.</span> <span class="nav-text">Set应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sorted-Set-应用场景"><span class="nav-number">7.</span> <span class="nav-text">Sorted Set 应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis使用场景"><span class="nav-number">8.</span> <span class="nav-text">Redis使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级用法"><span class="nav-number">9.</span> <span class="nav-text">高级用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis持久化"><span class="nav-number">10.</span> <span class="nav-text">Redis持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-–-内存快照（宕机快速恢复）"><span class="nav-number">11.</span> <span class="nav-text">RDB – 内存快照（宕机快速恢复）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">11.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快照时数据能修改吗"><span class="nav-number">11.2.</span> <span class="nav-text">快照时数据能修改吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加快照"><span class="nav-number">11.3.</span> <span class="nav-text">增加快照</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么时候fork子进程（触发RDB持久化机制）"><span class="nav-number">11.4.</span> <span class="nav-text">什么时候fork子进程（触发RDB持久化机制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优缺点"><span class="nav-number">11.5.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-—-避免数据丢失"><span class="nav-number">12.</span> <span class="nav-text">AOF — 避免数据丢失</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF三种写回策略"><span class="nav-number">12.1.</span> <span class="nav-text">AOF三种写回策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF重写机制"><span class="nav-number">12.2.</span> <span class="nav-text">AOF重写机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF-重写过程中有没有其他潜在的阻塞风险？"><span class="nav-number">12.3.</span> <span class="nav-text">AOF 重写过程中有没有其他潜在的阻塞风险？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF追加阻塞"><span class="nav-number">12.4.</span> <span class="nav-text">AOF追加阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优缺点-1"><span class="nav-number">12.5.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">13.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两者如何选择"><span class="nav-number">13.1.</span> <span class="nav-text">两者如何选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis过期键删除策略"><span class="nav-number">14.</span> <span class="nav-text">Redis过期键删除策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-内存淘汰策略"><span class="nav-number">15.</span> <span class="nav-text">Redis 内存淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存穿透"><span class="nav-number">16.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存击穿"><span class="nav-number">17.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存雪崩"><span class="nav-number">18.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#布隆过滤器"><span class="nav-number">19.</span> <span class="nav-text">布隆过滤器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存与数据库数据一致性"><span class="nav-number">20.</span> <span class="nav-text">缓存与数据库数据一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-先更新缓存，再更新DB"><span class="nav-number">20.1.</span> <span class="nav-text">1.先更新缓存，再更新DB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-先更新DB，再更新缓存"><span class="nav-number">20.2.</span> <span class="nav-text">2.先更新DB，再更新缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-先删除缓存，再更新DB"><span class="nav-number">20.3.</span> <span class="nav-text">3. 先删除缓存，再更新DB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-先更新DB，再删除缓存"><span class="nav-number">20.4.</span> <span class="nav-text">4.先更新DB，再删除缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单线程的redis为什么这么快"><span class="nav-number">21.</span> <span class="nav-text">单线程的redis为什么这么快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis变慢的场景"><span class="nav-number">22.</span> <span class="nav-text">Redis变慢的场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis架构模式"><span class="nav-number">23.</span> <span class="nav-text">Redis架构模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主从复制"><span class="nav-number">23.1.</span> <span class="nav-text">主从复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哨兵模式"><span class="nav-number">23.2.</span> <span class="nav-text">哨兵模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster高可用集群"><span class="nav-number">23.3.</span> <span class="nav-text">Redis Cluster高可用集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-相比-Memcached-有哪些优势？"><span class="nav-number">24.</span> <span class="nav-text">Redis 相比 Memcached 有哪些优势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么用redis而不用map等本地缓存做缓存？"><span class="nav-number">25.</span> <span class="nav-text">为什么用redis而不用map等本地缓存做缓存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">26.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wxning</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  





  

  

  

  
  

  

  

  

</body>
</html>
